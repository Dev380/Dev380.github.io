<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
        <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>

        
        
        

        

        
        
        

        
        
        

        
        
        

        <title>Scanning the whole Internet for Minecraft servers</title>
        
        <meta name="title" content="Scanning the whole Internet for Minecraft servers">
        
        <meta name="description" content="Some random ramblings">
        <meta name="generator" content="Zola v0.16.1">

        <meta property="og:type" content="website">
        <meta property="og:url" content="https://Dev380.github.io/blog/scanner-minecraft/">
        <meta property="og:site_name" content="Hello there üëã">
        <meta property="og:title" content="Scanning the whole Internet for Minecraft servers">
        <meta property="og:description" content="Some random ramblings">
        <meta property="og:image" content="https:&#x2F;&#x2F;Dev380.github.io&#x2F;images&#x2F;Dev380.png">

        
        
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="https://Dev380.github.io/blog/scanner-minecraft/">
        <meta property="twitter:title" content="Scanning the whole Internet for Minecraft servers">
        <meta property="twitter:description" content="Some random ramblings">
        <meta property="twitter:image" content="https:&#x2F;&#x2F;Dev380.github.io&#x2F;images&#x2F;Dev380.png">
        
        
        <link rel="canonical" href="https://Dev380.github.io/blog/scanner-minecraft/">
        <link rel="shortcut icon" type="image/x-icon" href="https://Dev380.github.io/images/Dev380.png">
        <script type="application/ld+json">
            {
                "description":"Some random ramblings",
                "url":"https://Dev380.github.io/blog/scanner-minecraft/",
                "@type":"WebSite",
                "headline":"Scanning the whole Internet for Minecraft servers",
                "name":"Scanning the whole Internet for Minecraft servers",
                
                "@context":"https://schema.org"
            }
        </script>
        
        
        
        <link rel="alternate" type="application/atom+xml" title="RSS" href="https://Dev380.github.io/atom.xml">
        
        
        
<link rel="preload" href="https://Dev380.github.io/style.css" as="style" crossorigin>
 <link rel="preload" href="/fonts/iosevka-regular.woff2" as="font" type="font/woff2" crossorigin>
 <link rel="stylesheet" href="https://Dev380.github.io/style.css"/>

    </head>
    <body theme="auto">
        <div class="w">
            <header>
                
                
<p><a href="..">..</a>/scanner-minecraft</p>
<p class="post-meta"><time datetime="2023-07-12">2023-07-12</time></p>
<h1>Scanning the whole Internet for Minecraft servers</h1>

            </header>
            <main class="page-content" aria-label="Content">
                



<p><em>This continues <a href="https://Dev380.github.io/blog/scanner-minecraft/blog/rewriting-ping-rust/">rewriting ping in rust</a>, please read that first</em></p>
<p>Raw sockets are interesting because they bypass most of the overhead of establishing a TCP connection, making efficient scanners possible, such as <a href="https://github.com/robertdavidgraham/masscan/">masscan</a>, that can scan the entire Internet in a reasonable amount of time. Of interest to me is open Minecraft servers - how could one scan the entire Internet for open port 25565 (Minecraft's port) IPs? This idea has been done to death, and many scanners are actively looking for servers on the open Internet right now. However, writing my own in Rust sounds like it would be an interesting experience.</p>
<p><hr data-content="start by bikeshedding" \>
Before actually doing scanning, I want to parse exclude files. Masscan supports excluding certain IP ranges (requires it, actually) to avoid scanning undesirable targets like 127.0.0.1 and the US military. To do this, the following file format is used:</p>
<ul>
<li>Comments start with &quot;#&quot; and are single line, like python</li>
<li>Each line consists of a regular IP address, one in CIDR notation or a range of IPs (e.g. 1.1.1.1-1.255.255.255)</li>
</ul>
<p>The singular adddress and ranges are pretty intuitive, but I must confess that I do not know anything about CIDR notation despite seeing it countless times. I found that this explanation helped me a lot:</p>
<ul>
<li>take a CIDR, for example 127.0.0.0/8</li>
<li>Convert the &quot;IP part&quot; to binary:</li>
</ul>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>01111111 00000000 00000000 00000000/8
</span></code></pre>
<ul>
<li>Find the first n bits, where n is the number after the IP. So 8 in this case. Now take those first n (8) bits from the IP.</li>
</ul>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>01111111
</span></code></pre>
<ul>
<li>Every address that starts with these bits is part of the &quot;network mask&quot; specified by the CIDR address 127.0.0.0/8</li>
</ul>
<p>This format seems simple enough to parse - remove comments, and check each line for a valid IP, CIDR or range. However, I'd like to make it needlessly complicated in order to learn one of the most mysterious concepts for me - parser combinators.</p>
<p>In C, parsers are usually created in the traditional imperative manner, going through a state machine to create its output. However, in Rust, it is more common to use a declarative approach, where an outline of the file to be parsed is specified and the library handles the rest. <code>nom</code> is by far the most popular, but I decided to go with <code>pest</code> for now. In <code>pest</code>, a &quot;formal grammar&quot; needs to be specified in a pseudo-<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> form, which defines the most basic units of a language (e.g. all alphanumeric characters and the plus sign), and ways to combine them to make valid expressions (sort of like regex). Here's the one I came up with for an exclude file:</p>
<pre data-lang="pest" style="background-color:#fdf6e3;color:#657b83;" class="language-pest "><code class="language-pest" data-lang="pest"><span>octet = { ASCII_DIGIT ~ ASCII_DIGIT? ~ ASCII_DIGIT? }
</span><span>address = @{ octet ~ &quot;.&quot; ~ octet ~ &quot;.&quot; ~ octet ~ &quot;.&quot; ~ octet }
</span><span>mask = { ASCII_DIGIT ~ ASCII_DIGIT? }
</span><span>cidr = { address ~ &quot;/&quot; ~ mask }
</span><span>range = { address ~ &quot;-&quot; ~ address }
</span><span>file = { SOI ~ ((cidr | range | address){,1} ~ NEWLINE )* ~ EOI }
</span><span>
</span><span>WHITESPACE = _{ &quot; &quot; }
</span><span>COMMENT = _{ &quot;#&quot; ~ (!NEWLINE ~ ANY)* }
</span></code></pre>
<p>The first line defines an <code>octet</code> as any 3 digit number (not really accurate, but checking if a number is in a range is above <code>pest</code>'s pay grade). The <code>~</code> means &quot;and then&quot;, the <code>ASCII_DIGIT</code> means any number from 0 to 9, and the <code>?</code> means the preceding symbol is optional. So, this should be read as &quot;an octet is a single digit followed by an optional other digit followed by another optional digit&quot;.</p>
<p>An address is defined as 4 octets separated by periods. Note the <code>@</code> in front - this means that no whitespace is allowed between the periods and the octets.</p>
<p>A mask (what I call the number after the slash in 127.0.0.0/8) is defined as any two digit number, similarly to octet.</p>
<p>A CIDR is simply an IP address, a slash and a number after.</p>
<p>A range is two IP addresses connected by a dash.</p>
<p>A <code>file</code> is the entire thing we'll be parsing - the <code>SOI</code> and <code>EOI</code> mean start/end of file, and tells <code>pest</code> that the whole file must follow this structure or it should fail. The <code>((cidr | range | address){,1} ~ NEWLINE )**</code> is similar to regex - each line should contain between 0 and 1 cidrs, ranges, or addresses, and there can be any number of lines.</p>
<p><code>WHITESPACE</code> and <code>COMMENT</code> are special variables that <code>pest</code> understands to match a single whitespace character os a single comment, and it'll automagically detect those and ignore them.</p>
<p><hr data-content="parsing 2: actual code" \>
In Rust, we need to use a macro to tell <code>pest</code> to generate a parser based on our <code>excludes.pest</code> file:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Parser)]
</span><span>#[</span><span style="color:#268bd2;">grammar </span><span style="color:#859900;">= </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">excludes.pest</span><span style="color:#839496;">&quot;</span><span>]
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">ExcludesParser</span><span>;
</span></code></pre>
<p>This will make the struct a <code>Parser</code> based on the grammar file, and will also generate an enum called <code>Rule</code> (basically token types that have been matched).</p>
<p>We can parse it and tell it to look for a valid <code>file</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_excludes</span><span>(</span><span style="color:#268bd2;">excludes</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">str</span><span>) {
</span><span>    ExcludesParser::parse(Rule::file, excludes)</span><span style="color:#859900;">?
</span></code></pre>
<p>This gives an iterator of <code>file</code>s, which we know will always have one element, namely the parsed file:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>ExcludesParser::parse(Rule::file, excludes)</span><span style="color:#859900;">?
</span><span>    .</span><span style="color:#859900;">next</span><span>()
</span><span>    .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">there should be a valid file!</span><span style="color:#839496;">&quot;</span><span>)
</span><span>    .</span><span style="color:#859900;">into_inner</span><span>()
</span></code></pre>
<p>The <code>into_inner</code> lets us access the tokens within the <code>file</code> in the abstract syntax tree structure (i.e., the addresses we are interested in). After filtering out <code>EOI</code>s which are matched for some reason:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>ExcludesParser::parse(Rule::file, excludes)</span><span style="color:#859900;">?
</span><span>    .</span><span style="color:#859900;">next</span><span>()
</span><span>    .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">there should be a valid file!</span><span style="color:#839496;">&quot;</span><span>)
</span><span>    .</span><span style="color:#859900;">into_inner</span><span>()
</span><span>    .</span><span style="color:#859900;">filter</span><span>(|</span><span style="color:#268bd2;">pair</span><span>| pair.</span><span style="color:#859900;">as_rule</span><span>() != Rule::</span><span style="color:#cb4b16;">EOI</span><span>)
</span></code></pre>
<p>We can match the parsed lines:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>.</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">pair</span><span>| </span><span style="color:#859900;">match</span><span> pair.</span><span style="color:#859900;">as_rule</span><span>() {
</span><span>    Rule::cidr </span><span style="color:#859900;">=&gt; parse_cidr</span><span>(pair),
</span><span>    Rule::range </span><span style="color:#859900;">=&gt; parse_range</span><span>(pair),
</span><span>    Rule::address </span><span style="color:#859900;">=&gt; parse_address</span><span>(pair),
</span></code></pre>
<p>and deal with each type of excluded IP range separately.</p>
<p>First, let's define an enum for parsed excluded IPs:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ExcludedIps </span><span>{
</span><span>    Cidr(Ipv4Addr, </span><span style="color:#268bd2;">u8</span><span>),
</span><span>    Range(Ipv4Addr, Ipv4Addr),
</span><span>    Address(Ipv4Addr),
</span><span>}
</span></code></pre>
<p><hr data-content="parsing cidrs" \>
We can use <code>into_inner</code> again to go one &quot;level&quot; deeper and get the parts of the CIDR that have matched (the address before the slash, and the number after). Then, we extract those two, parse them into Rust data types and put them in the <code>Cidr</code> enum variant (don't worry about the errors for now):</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_cidr</span><span>(</span><span style="color:#268bd2;">cidr</span><span>: Pair&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;ExcludedIps&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> cidr_iter = cidr.</span><span style="color:#859900;">into_inner</span><span>();
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip = cidr_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> mask = cidr_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;</span><span style="color:#268bd2;">u8</span><span>&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// Subnet mask is max 32
</span><span>    </span><span style="color:#859900;">if</span><span> mask &gt; </span><span style="color:#6c71c4;">32 </span><span>{
</span><span>        </span><span style="color:#859900;">Err</span><span>(Error::CidrMaskTooLarge(mask))
</span><span>    } </span><span style="color:#859900;">else </span><span>{
</span><span>        </span><span style="color:#859900;">Ok</span><span>(ExcludedIps::Cidr(ip, mask))
</span><span>    }
</span><span>}
</span></code></pre>
<p>{{ hr(data_content=&quot;parsing ranges and addresses) }}
Ranges are easy - it's the same as above (use <code>into_inner</code> to go one level deeper, and get the first two matched items) but with two IP addresses matched to create a range, rather than an IP address and a number.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_range</span><span>(</span><span style="color:#268bd2;">range</span><span>: Pair&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;ExcludedIps&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> range_iter = range.</span><span style="color:#859900;">into_inner</span><span>();
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip1 = range_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip2 = range_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">Ok</span><span>(ExcludedIps::Range(ip1, ip2))
</span><span>}
</span></code></pre>
<p>Singular IPs are even easier and don't need <code>into_inner</code> - just extract the IP address and parse it into a Rust data type:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_address</span><span>(</span><span style="color:#268bd2;">address</span><span>: Pair&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;ExcludedIps&gt; {
</span><span>    </span><span style="color:#859900;">Ok</span><span>(ExcludedIps::Address(address.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>))
</span><span>}
</span></code></pre>
<p><hr data-content="done parsing, back to networking" \>
Going back to the main parsing function, the <code>map</code> call just needs a branch for any <code>Rule</code>s that don't match:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>.</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">pair</span><span>| </span><span style="color:#859900;">match</span><span> pair.</span><span style="color:#859900;">as_rule</span><span>() {
</span><span>    Rule::cidr </span><span style="color:#859900;">=&gt; parse_cidr</span><span>(pair),
</span><span>    Rule::range </span><span style="color:#859900;">=&gt; parse_range</span><span>(pair),
</span><span>    Rule::address </span><span style="color:#859900;">=&gt; parse_address</span><span>(pair),
</span><span>    </span><span style="color:#859900;">_ =&gt; Err</span><span>(Error::InvalidLine(pair.</span><span style="color:#859900;">as_str</span><span>().</span><span style="color:#859900;">to_owned</span><span>())),
</span><span>})
</span><span>.</span><span style="color:#859900;">try_collect</span><span>()
</span></code></pre>
<p>The <code>try_collect</code> turns the iterator of parsed excluded IPs into a vector, throwing an error if any element of the iterator is an <code>Err</code>.</p>
<p>By the way, all the errors are automatically converted into a custom error type or part of a custom error type defined using the <code>thiserror</code> crate:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Error)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">Error </span><span>{
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Failed to parse:</span><span style="color:#dc322f;">\n</span><span style="color:#2aa198;">{0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    Parsing(#[</span><span style="color:#268bd2;">from</span><span>] pest::error::Error&lt;Rule&gt;),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">CIDR mask is greater than 32: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    CidrMaskTooLarge(</span><span style="color:#268bd2;">u8</span><span>),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Not an IP address: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    NotIp(#[</span><span style="color:#268bd2;">from</span><span>] AddrParseError),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Not a number: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    Nan(#[</span><span style="color:#268bd2;">from</span><span>] ParseIntError),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Invalid line: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    InvalidLine(</span><span style="color:#859900;">String</span><span>),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Parser failed for unknown reason</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    UnknownFailure
</span><span>}
</span></code></pre>
<p>And the entire file at the end of this is:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#268bd2;">allow</span><span>(clippy::result_large_err)]
</span><span style="color:#859900;">use </span><span>pest::{iterators::Pair, Parser};
</span><span style="color:#859900;">use </span><span>pest_derive::Parser;
</span><span style="color:#859900;">use </span><span>std::net::Ipv4Addr;
</span><span style="color:#859900;">use </span><span>thiserror::Error;
</span><span style="color:#859900;">use </span><span>std::net::AddrParseError;
</span><span style="color:#859900;">use </span><span>std::num::ParseIntError;
</span><span>
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Parser)]
</span><span>#[</span><span style="color:#268bd2;">grammar </span><span style="color:#859900;">= </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">excludes.pest</span><span style="color:#839496;">&quot;</span><span>]
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">ExcludesParser</span><span>;
</span><span>
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ExcludedIps </span><span>{
</span><span>    Cidr(Ipv4Addr, </span><span style="color:#268bd2;">u8</span><span>),
</span><span>    Range(Ipv4Addr, Ipv4Addr),
</span><span>    Address(Ipv4Addr),
</span><span>}
</span><span>
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">type </span><span style="color:#b58900;">Result</span><span>&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
</span><span>
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Error)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">Error </span><span>{
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Failed to parse:</span><span style="color:#dc322f;">\n</span><span style="color:#2aa198;">{0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    Parsing(#[</span><span style="color:#268bd2;">from</span><span>] pest::error::Error&lt;Rule&gt;),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">CIDR mask is greater than 32: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    CidrMaskTooLarge(</span><span style="color:#268bd2;">u8</span><span>),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Not an IP address: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    NotIp(#[</span><span style="color:#268bd2;">from</span><span>] AddrParseError),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Not a number: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    Nan(#[</span><span style="color:#268bd2;">from</span><span>] ParseIntError),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Invalid line: {0}</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    InvalidLine(</span><span style="color:#859900;">String</span><span>),
</span><span>    #[</span><span style="color:#268bd2;">error</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Parser failed for unknown reason</span><span style="color:#839496;">&quot;</span><span>)]
</span><span>    UnknownFailure
</span><span>}
</span><span>
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_excludes</span><span>(</span><span style="color:#268bd2;">excludes</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">str</span><span>) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;</span><span style="color:#859900;">Vec</span><span>&lt;ExcludedIps&gt;&gt; {
</span><span>    </span><span style="color:#93a1a1;">// We can unwrap because at least one file has to match
</span><span>    ExcludesParser::parse(Rule::file, excludes)</span><span style="color:#859900;">?
</span><span>        .</span><span style="color:#859900;">next</span><span>()
</span><span>        .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">there should be a valid file!</span><span style="color:#839496;">&quot;</span><span>)
</span><span>        .</span><span style="color:#859900;">into_inner</span><span>()
</span><span>        .</span><span style="color:#859900;">filter</span><span>(|</span><span style="color:#268bd2;">pair</span><span>| pair.</span><span style="color:#859900;">as_rule</span><span>() != Rule::</span><span style="color:#cb4b16;">EOI</span><span>)
</span><span>        .</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">pair</span><span>| </span><span style="color:#859900;">match</span><span> pair.</span><span style="color:#859900;">as_rule</span><span>() {
</span><span>            Rule::cidr </span><span style="color:#859900;">=&gt; parse_cidr</span><span>(pair),
</span><span>            Rule::range </span><span style="color:#859900;">=&gt; parse_range</span><span>(pair),
</span><span>            Rule::address </span><span style="color:#859900;">=&gt; parse_address</span><span>(pair),
</span><span>            </span><span style="color:#859900;">_ =&gt; Err</span><span>(Error::InvalidLine(pair.</span><span style="color:#859900;">as_str</span><span>().</span><span style="color:#859900;">to_owned</span><span>())),
</span><span>        })
</span><span>        .</span><span style="color:#859900;">try_collect</span><span>()
</span><span>}
</span><span>
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_cidr</span><span>(</span><span style="color:#268bd2;">cidr</span><span>: Pair&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;ExcludedIps&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> cidr_iter = cidr.</span><span style="color:#859900;">into_inner</span><span>();
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip = cidr_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> mask = cidr_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;</span><span style="color:#268bd2;">u8</span><span>&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// Subnet mask is max 32
</span><span>    </span><span style="color:#859900;">if</span><span> mask &gt; </span><span style="color:#6c71c4;">32 </span><span>{
</span><span>        </span><span style="color:#859900;">Err</span><span>(Error::CidrMaskTooLarge(mask))
</span><span>    } </span><span style="color:#859900;">else </span><span>{
</span><span>        </span><span style="color:#859900;">Ok</span><span>(ExcludedIps::Cidr(ip, mask))
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_range</span><span>(</span><span style="color:#268bd2;">range</span><span>: Pair&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;ExcludedIps&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> range_iter = range.</span><span style="color:#859900;">into_inner</span><span>();
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip1 = range_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip2 = range_iter.</span><span style="color:#859900;">next</span><span>().</span><span style="color:#859900;">ok_or</span><span>(Error::UnknownFailure)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">Ok</span><span>(ExcludedIps::Range(ip1, ip2))
</span><span>}
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_address</span><span>(</span><span style="color:#268bd2;">address</span><span>: Pair&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;ExcludedIps&gt; {
</span><span>    </span><span style="color:#859900;">Ok</span><span>(ExcludedIps::Address(address.</span><span style="color:#859900;">as_str</span><span>().parse::&lt;Ipv4Addr&gt;()</span><span style="color:#859900;">?</span><span>))
</span><span>}
</span></code></pre>
<p>After printing out the result of this function on a sample exclude.conf, here's the output:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">...
</span><span>        Address(
</span><span>            </span><span style="color:#6c71c4;">86.107</span><span>.</span><span style="color:#6c71c4;">32.28</span><span>,
</span><span>        ),
</span><span>        Address(
</span><span>            </span><span style="color:#6c71c4;">93.95</span><span>.</span><span style="color:#6c71c4;">216.59</span><span>,
</span><span>        ),
</span><span>        Address(
</span><span>            </span><span style="color:#6c71c4;">93.95</span><span>.</span><span style="color:#6c71c4;">216.18</span><span>,
</span><span>        ),
</span><span>        Address(
</span><span>            </span><span style="color:#6c71c4;">93.95</span><span>.</span><span style="color:#6c71c4;">216.162</span><span>,
</span><span>        ),
</span><span>        Cidr(
</span><span>            </span><span style="color:#6c71c4;">103.17</span><span>.</span><span style="color:#6c71c4;">20.160</span><span>,
</span><span>            </span><span style="color:#6c71c4;">29</span><span>,
</span><span>        ),
</span><span>        Range(
</span><span>            </span><span style="color:#6c71c4;">202.91</span><span>.</span><span style="color:#6c71c4;">162.0</span><span>,
</span><span>            </span><span style="color:#6c71c4;">202.91</span><span>.</span><span style="color:#6c71c4;">175.255</span><span>,
</span><span>        ),
</span><span>        Address(
</span><span>            </span><span style="color:#6c71c4;">167.114</span><span>.</span><span style="color:#6c71c4;">174.127</span><span>,
</span><span>        ),
</span><span>        Cidr(
</span><span>            </span><span style="color:#6c71c4;">200.160</span><span>.</span><span style="color:#6c71c4;">0.0</span><span>,
</span><span>            </span><span style="color:#6c71c4;">20</span><span>,
</span><span>        ),
</span><span>        Address(
</span><span>            </span><span style="color:#6c71c4;">188.192</span><span>.</span><span style="color:#6c71c4;">251.198</span><span>,
</span><span>        ),
</span><span>    ],
</span><span>)
</span></code></pre>
<p><hr data-content="i lied before, here is where I&#x27;ll actually go back to networking" \>
The layer 2 AF_PACKET API is the best fit for this program, as it is the fastest because the kernel does not need to do much except for passing the data to a network driver (see the <a href="/blog/rewriting-ping-rust/">ping article</a> for more info on raw sockets). So, let's create our socket:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">use </span><span>nix::{unistd, sys::socket::{socket, AddressFamily, SockFlag, SockType}};
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span>() {
</span><span>    </span><span style="color:#268bd2;">let</span><span> socket = socket::socket(
</span><span>        AddressFamily::Packet,
</span><span>        SockType::Raw,
</span><span>        SockFlag::empty(),
</span><span>        </span><span style="color:#859900;">None</span><span>,
</span><span>    );
</span><span>    unistd::close(socket).</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket close failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>}
</span></code></pre>
<p><hr data-content="i lied again, back to parsing" \>
Unfortunately, to do anything useful with the socket, we need some MAC addresses and interface indices. The <code>clap</code> crate is the standard for CLIs in Rust. All you have to do is write a struct defining all your arguments, and it'll generate everything else for you!</p>
<p>Here's the one for this program:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Parser, Debug)]
</span><span>#[</span><span style="color:#268bd2;">command</span><span>(author, version, about, long_about </span><span style="color:#859900;">=</span><span> None)]
</span><span style="color:#93a1a1;">/// A program to scan the whole Internet
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">Args </span><span>{
</span><span>    </span><span style="color:#93a1a1;">/// MAC address of gateway (router)
</span><span>    #[</span><span style="color:#268bd2;">arg</span><span>(short, long)]
</span><span>    </span><span style="color:#268bd2;">mac</span><span>: MacAddress,
</span><span>    </span><span style="color:#93a1a1;">/// Interface index
</span><span>    #[</span><span style="color:#268bd2;">arg</span><span>(short, long)]
</span><span>    </span><span style="color:#268bd2;">interface</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>}
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span>() {
</span><span>    </span><span style="color:#268bd2;">let</span><span> args = Args::parse();
</span><span>    </span><span style="color:#93a1a1;">// ...
</span></code></pre>
<p>And look what happens when running <code>jumboscan --help</code>:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>A program to scan the whole Internet
</span><span>
</span><span>Usage: jumboscan --mac &lt;MAC&gt; --interface &lt;INTERFACE&gt;
</span><span>
</span><span>Options:
</span><span>  -m, --mac &lt;MAC&gt;              MAC address of gateway (router)
</span><span>  -i, --interface &lt;INTERFACE&gt;  Interface index
</span><span>  -h, --help                   Print help
</span><span>  -V, --version                Print version
</span></code></pre>
<p>Now, we just have to create a <code>MacAddress</code> struct that implements <code>FromStr</code>.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Clone, Copy, Debug)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">MacAddress</span><span>([</span><span style="color:#268bd2;">u8</span><span>; 6]);
</span><span>
</span><span style="color:#268bd2;">impl </span><span style="color:#b58900;">MacAddress </span><span>{
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">as_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">self</span><span>) -&gt; [</span><span style="color:#268bd2;">u8</span><span>; </span><span style="color:#6c71c4;">6</span><span>] {
</span><span>        </span><span style="color:#d33682;">self</span><span>.</span><span style="color:#6c71c4;">0
</span><span>    }
</span><span>}
</span></code></pre>
<p>Of course, this also means we have to make another grammar for <code>pest</code> to parse! Firstly, a MAC address is just a set of bytes, which are two hex characters:</p>
<pre data-lang="pest" style="background-color:#fdf6e3;color:#657b83;" class="language-pest "><code class="language-pest" data-lang="pest"><span>mac_octet = { ASCII_HEX_DIGIT{2} }
</span></code></pre>
<p>There are two formats for MAC addresses <a href="https://www.ieee802.org/1/files/public/docs2020/yangsters-smansfield-mac-address-format-0420-v01.pdf">according to IEEE</a>: separated by colons (IETF format) and separated by hyphens (IEEE format, and preferred because it doesn't look like an IPv6 address). Technically, without any separators is allowed too, but I don't see that a lot in practice. Let's implement the IETF and IEEE versions:</p>
<pre data-lang="pest" style="background-color:#fdf6e3;color:#657b83;" class="language-pest "><code class="language-pest" data-lang="pest"><span>mac_octet = { ASCII_HEX_DIGIT{2} }
</span><span>ietf_mac = { (mac_octet ~ &quot;:&quot; ){5} ~ mac_octet }
</span><span>ieee_mac = { (mac_octet ~ &quot;-&quot;){5} ~ mac_octet }
</span><span>mac = { SOI ~ ietf_mac | ieee_mac ~ EOI }
</span></code></pre>
<p>We've defined a mac address as an IEEE or IETF mac address, which are defined as 6 octets separated by 5 of their respective separators. Now for some code - first we need to be able to decode single octets, using the <code>hex</code> crate:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">decode_octet</span><span>(</span><span style="color:#268bd2;">octet</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">str</span><span>) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> res = [</span><span style="color:#6c71c4;">0</span><span>; </span><span style="color:#6c71c4;">1</span><span>];
</span><span>    hex::decode_to_slice(octet, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> res)</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#859900;">Ok</span><span>(res[</span><span style="color:#6c71c4;">0</span><span>])
</span><span>}
</span></code></pre>
<p>Then we can decode a collection of octets:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">from_mac</span><span>(</span><span style="color:#586e75;">mut </span><span style="color:#268bd2;">mac</span><span>: Pairs&lt;&#39;</span><span style="color:#859900;">_</span><span>, Rule&gt;) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;MacAddress&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> bytes = [</span><span style="color:#6c71c4;">0</span><span>; </span><span style="color:#6c71c4;">6</span><span>];
</span><span>    </span><span style="color:#93a1a1;">// Should be safe to unwrap because exactly one type of mac address will be matched according to the grammar
</span><span>    </span><span style="color:#268bd2;">let</span><span> parts = mac
</span><span>        .</span><span style="color:#859900;">next</span><span>()
</span><span>        .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">exactly one type of mac should have matched</span><span style="color:#839496;">&quot;</span><span>)
</span><span>        .</span><span style="color:#859900;">into_inner</span><span>()
</span><span>        .</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">octet</span><span>| </span><span style="color:#859900;">decode_octet</span><span>(octet.</span><span style="color:#859900;">as_str</span><span>()))
</span><span>        .try_collect::&lt;</span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#859900;">_</span><span>&gt;&gt;()</span><span style="color:#859900;">?</span><span>;
</span><span>    bytes[</span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">6</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>parts[</span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">6</span><span>]);
</span><span>    </span><span style="color:#859900;">Ok</span><span>(MacAddress(bytes))
</span><span>}
</span></code></pre>
<p>And for the <code>FromStr</code> implementation that <code>clap</code> requires, we'll use <code>into_inner</code> to &quot;unwrap&quot; the <code>mac</code> into an <code>ietf_mac</code> or <code>ieee_mac</code>, then pass it to <code>from_mac</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">impl </span><span>FromStr </span><span style="color:#859900;">for </span><span style="color:#b58900;">MacAddress </span><span>{
</span><span>    </span><span style="color:#268bd2;">type </span><span style="color:#b58900;">Err </span><span>= ParseError;
</span><span>
</span><span>    </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">from_str</span><span>(</span><span style="color:#268bd2;">s</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">str</span><span>) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;</span><span style="color:#268bd2;">Self</span><span>&gt; {
</span><span>        </span><span style="color:#93a1a1;">// Should be safe to unwrap since we should have at least one match
</span><span>        </span><span style="color:#268bd2;">let</span><span> parsed = MacAddressParse::parse(Rule::mac, s)</span><span style="color:#859900;">?
</span><span>            .</span><span style="color:#859900;">next</span><span>()
</span><span>            .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">at least one mac should match</span><span style="color:#839496;">&quot;</span><span>);
</span><span>        </span><span style="color:#859900;">from_mac</span><span>(parsed.</span><span style="color:#859900;">into_inner</span><span>())
</span><span>    }
</span><span>}
</span></code></pre>
<p>Let's test the parser out:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ jumboscan --interface 1 --mac 2f:12:12:12:0000
</span><span>error: invalid value &#39;2f:12:12:12:0000&#39; for &#39;--mac &lt;MAC&gt;&#39;: Parsing failed:
</span><span> --&gt; 1:1
</span><span>  |
</span><span>1 | 2f:12:12:12:0000
</span><span>  | ^---
</span><span>  |
</span><span>  = expected mac
</span><span>
</span><span>For more information, try &#39;--help&#39;.
</span></code></pre>
<p>And with a correct MAC address...</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ jumboscan --interface 1 --mac 2f:12:12:12:00:00
</span></code></pre>
<p>It doesn't error! Now, I think we can <em>finally</em> return to actual networking</p>
<p>{{ hr(data_content&quot;hello networking, parsing won't be missed&quot;) }}
Alright, back to main:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span>() {
</span><span>    </span><span style="color:#268bd2;">let</span><span> args = Args::parse();
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> socket = socket::socket(
</span><span>        AddressFamily::Packet,
</span><span>        SockType::Raw,
</span><span>        SockFlag::</span><span style="color:#cb4b16;">SOCK_CLOEXEC</span><span>,
</span><span>        </span><span style="color:#859900;">None</span><span>,
</span><span>    );
</span><span>}
</span></code></pre>
<p>We can bind our socket to the interface and mac address given in the arguments. This will make sure we'll only receive ethernet frames that match the interface and address. As in the previous article, we need to construct a <code>sockaddr_ll</code>. Tl;dr, there's a lot of pointer casting magic.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> bind_addr = </span><span style="color:#586e75;">unsafe </span><span>{
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> addr_array = [</span><span style="color:#6c71c4;">0</span><span>; </span><span style="color:#6c71c4;">8</span><span>];
</span><span>    addr_array[</span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">6</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>args.mac.</span><span style="color:#859900;">as_bytes</span><span>());
</span><span>
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> storage = std::mem::zeroed::&lt;libc::sockaddr_storage&gt;();
</span><span>    </span><span style="color:#268bd2;">let</span><span> addr_pointer = </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> storage </span><span style="color:#859900;">as </span><span style="color:#586e75;">*mut </span><span>libc::sockaddr_storage </span><span style="color:#859900;">as </span><span style="color:#586e75;">*mut </span><span>libc::sockaddr_ll;
</span><span>    (*addr_pointer).sll_family = libc::</span><span style="color:#cb4b16;">AF_PACKET </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>;
</span><span>    (*addr_pointer).sll_protocol = libc::</span><span style="color:#cb4b16;">ETH_P_IP </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>;
</span><span>    (*addr_pointer).sll_ifindex = args.interface </span><span style="color:#859900;">as </span><span style="color:#268bd2;">i32</span><span>;
</span><span>    (*addr_pointer).sll_halen = </span><span style="color:#6c71c4;">6</span><span>;
</span><span>    (*addr_pointer).sll_addr = addr_array;
</span><span>    LinkAddr::from_raw(
</span><span>        </span><span style="color:#859900;">&amp;</span><span>storage </span><span style="color:#859900;">as </span><span style="color:#268bd2;">*const </span><span>libc::sockaddr_storage </span><span style="color:#859900;">as </span><span style="color:#268bd2;">*const </span><span>socket::sockaddr,
</span><span>        </span><span style="color:#859900;">None</span><span>,
</span><span>    )
</span><span>}
</span><span>.</span><span style="color:#859900;">ok_or</span><span>(anyhow::Error::msg(
</span><span>    </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Failed to create address object from interface &amp; mac</span><span style="color:#839496;">&quot;</span><span>,
</span><span>))</span><span style="color:#859900;">?</span><span>;
</span></code></pre>
<p>TL;DR, make a <code>sockaddr_storage</code>, cast it to a <code>sockaddr_ll</code> to modify the fields, then cast the <code>sockaddr_storage</code> to a <code>sockaddr</code>.</p>
<p>Now, we can finally bind the socket:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>socket::bind(socket, </span><span style="color:#859900;">&amp;</span><span>bind_addr).</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket binding failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span></code></pre>
<p>Finally, we need the interface's mac address and IP address to fill out our TCP packet. The correct way to do it would be to use <code>libc::getifaddrs</code>, but to make it a bit easier I'll use <code>default_net</code> and iterate through all the interfaces to find the source mac and ip:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let </span><span>(source_mac, source_ip) = {
</span><span>    </span><span style="color:#268bd2;">let</span><span> iface = default_net::get_interfaces()
</span><span>        .</span><span style="color:#859900;">iter</span><span>()
</span><span>        .</span><span style="color:#859900;">find</span><span>(|</span><span style="color:#268bd2;">iface</span><span>| iface.index == args.interface)
</span><span>        .</span><span style="color:#859900;">ok_or</span><span>(anyhow::Error::msg(
</span><span>            </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Failed to find interface with given index</span><span style="color:#839496;">&quot;</span><span>,
</span><span>        ))</span><span style="color:#859900;">?
</span><span>        .</span><span style="color:#859900;">clone</span><span>();
</span><span>    (
</span><span>        iface
</span><span>            .mac_addr
</span><span>            .</span><span style="color:#859900;">ok_or</span><span>(anyhow::Error::msg(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Interface has no mac address</span><span style="color:#839496;">&quot;</span><span>))</span><span style="color:#859900;">?
</span><span>            .</span><span style="color:#859900;">octets</span><span>(),
</span><span>        iface
</span><span>            .ipv4
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">0</span><span>)
</span><span>            .</span><span style="color:#859900;">ok_or</span><span>(anyhow::Error::msg(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Interface has no ipv4 address</span><span style="color:#839496;">&quot;</span><span>))</span><span style="color:#859900;">?
</span><span>            .addr
</span><span>            .</span><span style="color:#859900;">octets</span><span>(),
</span><span>    )
</span><span>};
</span></code></pre>
<p>Then we just need a byte array &quot;template&quot; for a TCP syn packet (the first one sent to initialize a connection). It'll be similar to the one in my last article, but instead of ICMP on top of IPv4 it'll be TCP. As in the previous article, we need an ethernet header:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0
</span></code></pre>
<p>The first 12 bytes are the 6 byte destination and source MAC addresses respectively (to be filled in later), and the last 2 are 0x0800 in big-endian, which is the protocol number for IPv4. This tells the network interface what device to send the packet to (the router's MAC address) and who it should return to (the interface itself). After that, we'll need the 20-byte IPv4 header:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>69, 0, 0, 40, 0, 0, 0, 0, 64, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
</span></code></pre>
<p><img src="/images/ipv4_header.png" alt="IPv4 header" />
The first byte is always 69, and encodes the IP version (4) and the length of the header in 4-byte &quot;words&quot; (5), and is thus equal to 0x45. The next byte is always 0, and the next two bytes are 40 in big endian, as the length of the IP header + TCP data is 40. The 64 specifies the time-to-live (it gets decremented by 1 each time it passes through another device, and the packet is dropped when it's 0), and the 6 is the protocol number for TCP. The two bytes after the 6 are the checksum, and the rest of the 8 bytes are the source and destination IP addresses respectively.</p>
<p>Finally, the TCP header part:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 2, 250, 240, 0, 0, 0, 0
</span></code></pre>
<p><img src="/images/tcp_header.png" alt="TCP header" />
The 80 is the data offset, AKA the size of the TCP header times 16 (because of the 4 reserved bits), measured in 4 byte words as with the IP header length. Unlike the IP header, this is only the length of the header and not the header and data. The 2 is the flag for SYN, which is turned on for the SYN packet. The window size is the same as Linux.</p>
<p>Putting these together, we get a byte array of a blank SYN:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">BLANK_SYN</span><span>: [</span><span style="color:#268bd2;">u8</span><span>; </span><span style="color:#6c71c4;">54</span><span>] = [ </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">8</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">69</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">40</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">64</span><span>, </span><span style="color:#6c71c4;">6</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">80</span><span>, </span><span style="color:#6c71c4;">2</span><span>, </span><span style="color:#6c71c4;">250</span><span>, </span><span style="color:#6c71c4;">240</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">0 </span><span>];
</span></code></pre>
<p>Then, we can fill out info only known at runtime:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> blank_syn = </span><span style="color:#cb4b16;">BLANK_SYN</span><span>;
</span><span>blank_syn[</span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">6</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>args.mac.</span><span style="color:#859900;">as_bytes</span><span>()); </span><span style="color:#93a1a1;">// destination MAC
</span><span>blank_syn[</span><span style="color:#6c71c4;">6</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">12</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>source_mac); </span><span style="color:#93a1a1;">// source MAC
</span><span>blank_syn[</span><span style="color:#6c71c4;">26</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">30</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>source_ip); </span><span style="color:#93a1a1;">// source IP
</span><span>blank_syn[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">36</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>args.source_port.</span><span style="color:#859900;">to_be_bytes</span><span>()); </span><span style="color:#93a1a1;">// source TCP port
</span><span>blank_syn[</span><span style="color:#6c71c4;">36</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">38</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>args.dest_port.</span><span style="color:#859900;">to_be_bytes</span><span>()); </span><span style="color:#93a1a1;">// destination TCP port
</span></code></pre>
<p>We can make a function to calculate both the IP and TCP checksums, with the <code>internet_checksum</code> crate. First, for IP:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">calculate_checksums</span><span>(</span><span style="color:#268bd2;">packet</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> [</span><span style="color:#268bd2;">u8</span><span>]) {
</span><span>    </span><span style="color:#93a1a1;">// IP header
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip_checksum = internet_checksum::checksum(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">14</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>]);
</span><span>    packet[</span><span style="color:#6c71c4;">24</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">26</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>ip_checksum);
</span></code></pre>
<p>TCP is trickier because a &quot;pseudoheader&quot; is attached before the TCP header when the checksum is calculated.
<img src="/iamges/tcp_pseudoheader.png" alt="TCP pseudoheader" />
We can manually add bytes to the tcp checksum for the pseudoheader:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// TCP
</span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> tcp_checksum = Checksum::new();
</span><span style="color:#93a1a1;">// Pseudoheader = source IP + dest IP + byte of zeros + protocol number (6) + TCP length
</span><span style="color:#93a1a1;">// We need to add these bytes first then add the actual TCP header + data
</span><span>tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">26</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">30</span><span>]);
</span><span>tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">30</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>]);
</span><span>tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">6</span><span>]);
</span><span>tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>((packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>()));
</span></code></pre>
<p>Then add the real TCP header and data to the checksum:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// Actual TCP stuff here
</span><span>tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span>]);
</span><span>packet[</span><span style="color:#6c71c4;">50</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">52</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>tcp_checksum.</span><span style="color:#859900;">checksum</span><span>());
</span></code></pre>
<p>The whole function looks like this:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">calculate_checksums</span><span>(</span><span style="color:#268bd2;">packet</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> [</span><span style="color:#268bd2;">u8</span><span>]) {
</span><span>    </span><span style="color:#93a1a1;">// IP header
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip_checksum = internet_checksum::checksum(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">14</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>]);
</span><span>    packet[</span><span style="color:#6c71c4;">24</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">26</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>ip_checksum);
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// TCP
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> tcp_checksum = Checksum::new();
</span><span>    </span><span style="color:#93a1a1;">// Pseudoheader = source IP + dest IP + byte of zeros + protocol number (6) + TCP length
</span><span>    </span><span style="color:#93a1a1;">// We need to add these bytes first then add the actual TCP header + data
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">26</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">30</span><span>]);
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">30</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>]);
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">6</span><span>]);
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>((packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>()));
</span><span>    </span><span style="color:#93a1a1;">// Actual TCP stuff here
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span>]);
</span><span>    packet[</span><span style="color:#6c71c4;">50</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">52</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>tcp_checksum.</span><span style="color:#859900;">checksum</span><span>());
</span><span>}
</span></code></pre>
<p>And now we can make a function to create a SYN packet given a template and a destination IP:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">create_syn</span><span>(</span><span style="color:#268bd2;">blank_syn</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> [</span><span style="color:#268bd2;">u8</span><span>], </span><span style="color:#268bd2;">dest_ip</span><span>: [</span><span style="color:#268bd2;">u8</span><span>; 4]) {
</span><span>    blank_syn[</span><span style="color:#6c71c4;">30</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>dest_ip);
</span><span>    </span><span style="color:#859900;">calculate_checksums</span><span>(blank_syn);
</span><span>}
</span></code></pre>
<p>Finally, we can send our first SYN!</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// in main
</span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> syn = blank_syn;
</span><span style="color:#859900;">create_syn</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> syn, [</span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#6c71c4;">1</span><span>]);
</span><span>socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>syn, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty()).</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>; 
</span></code></pre>
<p>Let's run it (with my router's MAC address from <code>ip neigh</code>):</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ sudo jumboscan --interface 3 --mac 04:d4:c4:1a:0b:a8 --source-port 42069 --dest-port 443
</span></code></pre>
<p>What does our good friend <code>tcpdump</code> have to say? Did it capture our SYN and a SYN-ACK in response?</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ sudo tcpdump -vennSxs 0 tcp and host 1.1.1.1
</span><span>[sudo] password for Dev380: 
</span><span>tcpdump: listening on wlan0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
</span><span>14:11:42.159793 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 54: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 40)
</span><span>    192.168.50.161.42069 &gt; 1.1.1.1.443: Flags [S], cksum 0x1996 (correct), seq 0, win 64240, length 0
</span><span>    0x0000:  4500 0028 0000 0000 4006 8585 c0a8 32a1
</span><span>    0x0010:  0101 0101 a455 01bb 0000 0000 0000 0000
</span><span>    0x0020:  5002 faf0 1996 0000
</span><span>14:11:42.168118 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 60: (tos 0x0, ttl 57, id 0, offset 0, flags [DF], proto TCP (6), length 44)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.42069: Flags [S.], cksum 0x734b (correct), seq 361527545, ack 1, win 64240, options [mss 1452], length 0
</span><span>    0x0000:  4500 002c 0000 4000 3906 4c81 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb a455 158c 78f9 0000 0001
</span><span>    0x0020:  6012 faf0 734b 0000 0204 05ac 0000
</span><span>14:11:43.203299 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 60: (tos 0x0, ttl 57, id 0, offset 0, flags [DF], proto TCP (6), length 44)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.42069: Flags [S.], cksum 0x734b (correct), seq 361527545, ack 1, win 64240, options [mss 1452], length 0
</span><span>    0x0000:  4500 002c 0000 4000 3906 4c81 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb a455 158c 78f9 0000 0001
</span><span>    0x0020:  6012 faf0 734b 0000 0204 05ac 0000
</span></code></pre>
<p>It works! Strangly, 1.1.1.1 is sending back two identical SYN-ACKs in response.</p>
<p><hr data-content="finishing connections (we&#x27;re still not halfway done after this!)" \>
Now that we are capable of sending SYNs to initiatve them, we need to complete the &quot;embryo&quot;, &quot;half-open&quot; or &quot;zombie&quot; connections to send any useful data and get info about Minecraft servers across the Internet (you probably forgot that was the point of all this - don't worry, I did too). TCP has a 3-way handshake model, so connections are established like this:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>SYN    ---------&gt; server
</span><span>client &lt;--------- SYN-ACK
</span><span>ACK    ---------&gt; server
</span></code></pre>
<p>After this, the connection is &quot;full-duplexed&quot; amd established. The SYN packet we just built means &quot;synchronize sequence number&quot;, which is supposed to tell the server to read the number in the sequence number field of the TCP header (which we set to 0, but should be random according to RFC 1948). The server responds with another header-only packet called SYN-ACK, which has both SYN and ACK flags set and means &quot;we've acknowledged the sequence number you sent&quot;. The server gets to choose its own random number to set in the sequence number field, and the acknowledgement field is the client's sequence number plus one. The ACK part of the TCP handshake is sort of a misnomer, since every packet after the initial SYN should have this flag set. The ACK flag just means &quot;we have received all your previous messages, proved by the fact that my acknowledgment number is correct.&quot; After this point in the handshake, the connection is &quot;normal&quot; and every packet is an ACK that can carry some data.</p>
<p><hr data-content="minecraft&#x27;s protocol: another tiny detour" \>
So, since the end of the TCP 3-way handshake is an ACK packet that can carry data, we should probably decide what data it should carry. This is the traditional layer 7/application layer that anyone implementing a protocol on top of TCP would use (e.g. HTTP). The de facto authority on Minecraft's application layer protocol is <a href="https://wiki.vg/Server_List_Ping">wiki.vg</a> which has info on the serve list ping protocol that allows us to gather information on Minecraft servers. We'll send a handshake packet in the finished application, but for now we'll use an HTTP GET request to 1.1.1.1:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>GET / HTTP/1.1
</span><span>Host: 1.1.1.1
</span><span>(two newlines here)
</span></code></pre>
<p><hr data-content="the hardest way to make an HTTP request" \>
To complete a TCP connection and send/receive data, we'll need to process packets from the server. As we need to receive at least 2 types of packets from the server (SYN-ACK and the server's response to whatever our request is), we'll need a way to distinguish between different types of server responses, as the real application will receive TCP packets asynchronously from many different servers. Fortunately, the &quot;leave sequence number at 0&quot; shortcut allows for a nice hack: the acknowledgement number of a SYN-ACK will always be 1 (because it's 1 more than the initial sequence number), and the acknowledgement number of the first server response will always be 2 (1 from the SYN-ACK, and ACK = last SYN + 1).</p>
<p>First, let's move all the TCP stuff to <code>tcp.rs</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">use </span><span>internet_checksum::Checksum;
</span><span>
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">create_syn</span><span>(</span><span style="color:#268bd2;">blank_syn</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> [</span><span style="color:#268bd2;">u8</span><span>], </span><span style="color:#268bd2;">dest_ip</span><span>: [</span><span style="color:#268bd2;">u8</span><span>; 4]) {
</span><span>    blank_syn[</span><span style="color:#6c71c4;">30</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>dest_ip);
</span><span>    </span><span style="color:#859900;">calculate_checksums</span><span>(blank_syn);
</span><span>}
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">calculate_checksums</span><span>(</span><span style="color:#268bd2;">packet</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> [</span><span style="color:#268bd2;">u8</span><span>]) {
</span><span>    </span><span style="color:#93a1a1;">// IP header
</span><span>    </span><span style="color:#268bd2;">let</span><span> ip_checksum = internet_checksum::checksum(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">14</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>]);
</span><span>    packet[</span><span style="color:#6c71c4;">24</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">26</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>ip_checksum);
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// TCP
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> tcp_checksum = Checksum::new();
</span><span>    </span><span style="color:#93a1a1;">// Pseudoheader = source IP + dest IP + byte of zeros + protocol number (6) + TCP length
</span><span>    </span><span style="color:#93a1a1;">// We need to add these bytes first then add the actual TCP header + data
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">26</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">30</span><span>]);
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">30</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">34</span><span>]);
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#6c71c4;">0</span><span>, </span><span style="color:#6c71c4;">6</span><span>]);
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>((packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>()));
</span><span>    </span><span style="color:#93a1a1;">// Actual TCP stuff here
</span><span>    tcp_checksum.</span><span style="color:#859900;">add_bytes</span><span>(</span><span style="color:#859900;">&amp;</span><span>packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span>]);
</span><span>    packet[</span><span style="color:#6c71c4;">50</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">52</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>tcp_checksum.</span><span style="color:#859900;">checksum</span><span>());
</span><span>}
</span></code></pre>
<p>Then, let's initialize the server packet parsing function:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ServerPacket </span><span>{}
</span><span>
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_server_packet</span><span>(</span><span style="color:#268bd2;">server_packet</span><span>: </span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#268bd2;">u8</span><span>], </span><span style="color:#268bd2;">source_port</span><span>: </span><span style="color:#268bd2;">u16</span><span>) -&gt; </span><span style="color:#859900;">Option</span><span>&lt;ServerPacket&gt; {
</span><span>    </span><span style="color:#268bd2;">let</span><span> received_port = </span><span style="color:#268bd2;">u16</span><span>::from_be_bytes(
</span><span>        server_packet[</span><span style="color:#6c71c4;">36</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">38</span><span>]
</span><span>            .</span><span style="color:#859900;">try_into</span><span>()
</span><span>            .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">36..38 should be [u8; 2]</span><span style="color:#839496;">&quot;</span><span>),
</span><span>    );
</span><span>    </span><span style="color:#859900;">if</span><span> received_port != source_port {
</span><span>        </span><span style="color:#859900;">return None</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>We're first checking to see if the destination port is the same as our source port, to avoid colliding with other applications on the same device that are using TCP. Linux doesn't use really high port numbers for automatically generated source ports, so we can just use one of those to make sure no collisions occur and we don't intercept packets meant for other applications.</p>
<p>Since we're using acknowledgement numbers to identify packet types, let's extract that:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> acknowledgement_number = </span><span style="color:#268bd2;">u32</span><span>::from_be_bytes(
</span><span>    server_packet[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>]
</span><span>        .</span><span style="color:#859900;">try_into</span><span>()
</span><span>        .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">42..46 should be [u8; 4]</span><span style="color:#839496;">&quot;</span><span>),
</span><span>);
</span></code></pre>
<p>Then, let's make a new enum variant for a syn-ack, and match that:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ServerPacket </span><span>{
</span><span>    SynAck,
</span><span>}
</span><span style="color:#93a1a1;">// ...
</span><span style="color:#93a1a1;">// in parse_server_packet
</span><span style="color:#859900;">match</span><span> acknowledgement_number {
</span><span>    </span><span style="color:#6c71c4;">1 </span><span style="color:#859900;">=&gt; Some</span><span>(ServerPacket::SynAck),
</span><span>    </span><span style="color:#6c71c4;">2 </span><span style="color:#859900;">=&gt; </span><span>{ </span><span style="color:#859900;">todo!</span><span>() },
</span><span>    </span><span style="color:#859900;">_ =&gt; None</span><span>,
</span><span>}
</span></code></pre>
<p>An acknowledgement number of 3 means that the server is responding with data after an ACK. This is a bit weird to process, because of something I skipped over when discussing IP and TCP headers...</p>
<p>The first byte of an IPv4 header is 69 because I hardcoded the length of the header at 5 words, or 20 bytes. However, if there are more words, then optional fields aptly named &quot;options&quot; can be used. For numerous reasons, these are used infrequently in IPv4. However, TCP has options too, and those are more commonly used (e.g. Linux adds a timestamp as an option field). This is why the TCP header length field is also called a data offset - we need to add this offset to the length of the ethernet + ip headers in order to see when the data actually starts.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#6c71c4;">2 </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data_offset = server_packet[</span><span style="color:#6c71c4;">46</span><span>];
</span><span>    data_offset &gt;&gt;= </span><span style="color:#6c71c4;">4</span><span>;
</span><span>},
</span></code></pre>
<p>Recall that the data offset field is shifted 4 bits to the left because it is followed by 4 &quot;reserved&quot; bits - this is why we need to shift it back to correct for this.</p>
<p>Now, we just need to update <code>ServerPacket</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ServerPacket </span><span>{
</span><span>    SynAck,
</span><span>    Data(</span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt;), </span><span style="color:#93a1a1;">// new!
</span><span>}
</span></code></pre>
<p>And process the data!</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#6c71c4;">2 </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>    </span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN</span><span>: </span><span style="color:#268bd2;">usize </span><span>= </span><span style="color:#6c71c4;">34</span><span>;
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data_offset = server_packet[</span><span style="color:#6c71c4;">46</span><span>] </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span>;
</span><span>    data_offset &gt;&gt;= </span><span style="color:#6c71c4;">4</span><span>;
</span><span>    </span><span style="color:#859900;">Some</span><span>(ServerPacket::Data(server_packet[</span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">to_vec</span><span>()))
</span><span>}
</span></code></pre>
<p>One minor flaw - array indexing/slicing in rust implicitly panics when the index is out of bounds, which could be a security flaw. Let's add a check for that:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN</span><span>: </span><span style="color:#268bd2;">usize </span><span>= </span><span style="color:#6c71c4;">34</span><span>;
</span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">MIN_TCP_HEADER_LEN</span><span>: </span><span style="color:#268bd2;">usize </span><span>= </span><span style="color:#6c71c4;">20</span><span>;
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">parse_server_packet</span><span>(</span><span style="color:#268bd2;">server_packet</span><span>: </span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#268bd2;">u8</span><span>], </span><span style="color:#268bd2;">source_port</span><span>: </span><span style="color:#268bd2;">u16</span><span>) -&gt; </span><span style="color:#859900;">Option</span><span>&lt;ServerPacket&gt; {
</span><span>    </span><span style="color:#859900;">if</span><span> server_packet.</span><span style="color:#859900;">len</span><span>() &lt; </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ </span><span style="color:#cb4b16;">MIN_TCP_HEADER_LEN </span><span>{
</span><span>        </span><span style="color:#859900;">return None</span><span>;
</span><span>    }
</span></code></pre>
<p>And another check when matching a data packet to make sure the data offset is correct:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#6c71c4;">2 </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data_offset = server_packet[</span><span style="color:#6c71c4;">46</span><span>] </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span>;
</span><span>    data_offset &gt;&gt;= </span><span style="color:#6c71c4;">4</span><span>;
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// new!
</span><span>    </span><span style="color:#859900;">if</span><span> server_packet.</span><span style="color:#859900;">len</span><span>() &lt; </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset {
</span><span>        </span><span style="color:#859900;">return None</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#859900;">Some</span><span>(ServerPacket::Data(server_packet[</span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">to_vec</span><span>()))
</span><span>}
</span><span>`
</span><span>
</span><span>Now, we just have to test it</span><span style="color:#859900;">!</span><span> In `main.rs`, </span><span style="color:#268bd2;">let</span><span style="color:#586e75;">&#39;s</span><span> read packets </span><span style="color:#859900;">in</span><span> an infinite </span><span style="color:#859900;">loop</span><span>, and pass them to `parse_server_packet`. If it</span><span style="color:#586e75;">&#39;s</span><span> successful and returns a `</span><span style="color:#859900;">Some</span><span>`, we can print out the result:
</span><span>```rust
</span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">MAX_PACKET_SIZE</span><span>: </span><span style="color:#268bd2;">usize </span><span>= </span><span style="color:#6c71c4;">65536</span><span>;
</span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> recv_buffer = [</span><span style="color:#6c71c4;">0</span><span>; </span><span style="color:#cb4b16;">MAX_PACKET_SIZE</span><span>];
</span><span style="color:#859900;">loop </span><span>{
</span><span>    </span><span style="color:#268bd2;">let</span><span> read_bytes = unistd::read(socket, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> recv_buffer).</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket read failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span>(server_packet) = tcp::parse_server_packet(</span><span style="color:#859900;">&amp;</span><span>recv_buffer[</span><span style="color:#6c71c4;">14</span><span style="color:#859900;">..</span><span>read_bytes], args.source_port) {
</span><span>        </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#cb4b16;">{server_packet:?}</span><span style="color:#839496;">&quot;</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>And running it...</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>(it&#39;s just hanging forever)
</span></code></pre>
<p>There's nothing there. It's stuck on the first read call.</p>
<p>Let's look through the <code>afpacket</code> crate (which also uses raw sockets) to see if it has any clues on why this doesn't work.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// afpacket/src/sync.rs lines 67-82
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">bind_by_index</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">self</span><span>, </span><span style="color:#268bd2;">ifindex</span><span>: </span><span style="color:#268bd2;">i32</span><span>) -&gt; </span><span style="color:#859900;">Result</span><span>&lt;()&gt; {
</span><span>    </span><span style="color:#586e75;">unsafe </span><span>{
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ss: sockaddr_storage = std::mem::zeroed();
</span><span>        </span><span style="color:#268bd2;">let</span><span> sll: </span><span style="color:#586e75;">*mut</span><span> sockaddr_ll = </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> ss </span><span style="color:#859900;">as </span><span style="color:#586e75;">*mut</span><span> sockaddr_storage </span><span style="color:#859900;">as </span><span style="color:#586e75;">*mut</span><span> sockaddr_ll;
</span><span>        (*sll).sll_family = </span><span style="color:#cb4b16;">AF_PACKET </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>;
</span><span>        (*sll).sll_protocol = (</span><span style="color:#cb4b16;">ETH_P_ALL </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be</span><span>();
</span><span>        (*sll).sll_ifindex = ifindex;
</span><span>
</span><span>        </span><span style="color:#268bd2;">let</span><span> sa = (</span><span style="color:#859900;">&amp;</span><span>ss </span><span style="color:#859900;">as </span><span style="color:#268bd2;">*const </span><span>libc::sockaddr_storage) </span><span style="color:#859900;">as </span><span style="color:#268bd2;">*const </span><span>libc::sockaddr;
</span><span>        </span><span style="color:#268bd2;">let</span><span> res = libc::bind(</span><span style="color:#d33682;">self</span><span>.</span><span style="color:#6c71c4;">0</span><span>, sa, std::mem::size_of::&lt;sockaddr_ll&gt;() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u32</span><span>);
</span><span>        </span><span style="color:#859900;">if</span><span> res == -</span><span style="color:#6c71c4;">1 </span><span>{
</span><span>            </span><span style="color:#859900;">return Err</span><span>(Error::last_os_error());
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#859900;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<p>Oh no, I've made another silly mistake! My code is:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>(*addr_pointer).sll_protocol = libc::</span><span style="color:#cb4b16;">ETH_P_IP </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>;
</span></code></pre>
<p>I seem to have forgotten to convert the protocol number to big endian, as <code>afpacket</code> did. Let's fix that:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>(*addr_pointer).sll_protocol = (libc::</span><span style="color:#cb4b16;">ETH_P_IP </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be</span><span>();
</span></code></pre>
<p>Thanks to <code>afpacket</code> for saving me twice from endless frustration in both this article and my previous one. üòå</p>
<p>Now, running it should work...</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ sudo jumboscan --interface 3 --mac 04:d4:c4:1a:0b:a8&#39; --source-port 65535 --dest-port 443
</span><span>SynAck
</span><span>SynAck
</span></code></pre>
<p>Perfect! We've received two SYN-ACKs, just as <code>tcpdump</code> tells us 1.1.1.1 does. Now we need to respond to SYN-ACKs. In order to send an ACK, we need to know the IP and source port of the SYN-ACK packet, so let's make a few changes to the <code>ServerPacket</code> returned by <code>parse_server_packet</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// previously ServerPacket
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ServerPacketType </span><span>{
</span><span>    SynAck,
</span><span>    Data(</span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt;),
</span><span>}
</span><span>
</span><span style="color:#93a1a1;">// new!
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">ServerPacket </span><span>{
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">ip</span><span>: [</span><span style="color:#268bd2;">u8</span><span>; 4],
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">port</span><span>: [</span><span style="color:#268bd2;">u8</span><span>; 2],
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">seuqnece_number</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">packet_type</span><span>: ServerPacketType,
</span><span>}
</span></code></pre>
<p>We're leaving the port number as a <code>[u8; 2]</code> as a micro-optimization, because if it's a <code>u16</code>, it'll have to be converted back into a <code>[u8; 2]</code> for sending anyway.</p>
<p>Let's fix <code>parse_server_packet</code> to work with the new <code>ServerPacket</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// previously just returned this
</span><span style="color:#268bd2;">let</span><span> packet_type = </span><span style="color:#859900;">match</span><span> acknowledgement_number {
</span><span>    </span><span style="color:#6c71c4;">1 </span><span style="color:#859900;">=&gt; Some</span><span>(ServerPacketType::SynAck),
</span><span>    </span><span style="color:#6c71c4;">2 </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data_offset = server_packet[</span><span style="color:#6c71c4;">46</span><span>] </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span>;
</span><span>        data_offset &gt;&gt;= </span><span style="color:#6c71c4;">4</span><span>;
</span><span>
</span><span>        </span><span style="color:#859900;">if</span><span> server_packet.</span><span style="color:#859900;">len</span><span>() &lt; </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset {
</span><span>            </span><span style="color:#859900;">return None</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#859900;">Some</span><span>(ServerPacketType::Data(
</span><span>            server_packet[</span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">to_vec</span><span>(),
</span><span>        ))
</span><span>    }
</span><span>    </span><span style="color:#859900;">_ =&gt; None</span><span>,
</span><span>}</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span style="color:#93a1a1;">// new!
</span><span style="color:#268bd2;">let</span><span> ip = server_packet[</span><span style="color:#6c71c4;">26</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">30</span><span>].</span><span style="color:#859900;">try_into</span><span>().</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">26..30 should be [u8; 4]</span><span style="color:#839496;">&quot;</span><span>);
</span><span style="color:#268bd2;">let</span><span> port = server_packet[</span><span style="color:#6c71c4;">34</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">36</span><span>].</span><span style="color:#859900;">try_into</span><span>().</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">34..36 should be [u8; 2]</span><span style="color:#839496;">&quot;</span><span>);
</span><span style="color:#268bd2;">let</span><span> sequence_number = </span><span style="color:#268bd2;">u32</span><span>::from_be_bytes(
</span><span>    server_packet[</span><span style="color:#6c71c4;">38</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">42</span><span>]
</span><span>        .</span><span style="color:#859900;">try_into</span><span>()
</span><span>        .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">38..42 should be [u8; 4]</span><span style="color:#839496;">&quot;</span><span>),
</span><span>);
</span><span style="color:#859900;">Some</span><span>(ServerPacket {
</span><span>    ip,
</span><span>    port,
</span><span>    sequence_number,
</span><span>    packet_type
</span><span>})
</span></code></pre>
<p>We can add some more print statements for debugging:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// fn main
</span><span style="color:#859900;">loop </span><span>{
</span><span>    </span><span style="color:#268bd2;">let</span><span> read_bytes = unistd::read(socket, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> recv_buffer).</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket read failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> packet = tcp::parse_server_packet(</span><span style="color:#859900;">&amp;</span><span>recv_buffer[</span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span>read_bytes], args.source_port);
</span><span>
</span><span>    </span><span style="color:#859900;">if </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span>(packet) = packet {
</span><span>        </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">type: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.packet_type);
</span><span>        </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">ip: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.ip);
</span><span>        </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">port: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.port);
</span><span>        </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">seq: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.sequence_number);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Let's make a template byte array for an ACK now. It'll be the exact same as a SYN packet, but with the TCP flag set to ACK (16) instead of SYN (2). Also, since we send sequence numbers of 0 in SYNs, our next packet should have a sequence number of 1.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> blank_ack = blank_syn;
</span><span style="color:#93a1a1;">// Set TCP flags to ACK
</span><span>blank_ack[</span><span style="color:#6c71c4;">47</span><span>] = </span><span style="color:#6c71c4;">16</span><span>;
</span><span style="color:#93a1a1;">// Set sequence number to 1
</span><span>blank_ack[</span><span style="color:#6c71c4;">38</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">42</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#6c71c4;">1</span><span style="color:#268bd2;">u32</span><span>.</span><span style="color:#859900;">to_be_bytes</span><span>());
</span></code></pre>
<p>Also, the <code>create_syn</code> function to create a new SYN packet works for an ACK too, so let's rename it:</p>
<pre data-lang="diff" style="background-color:#fdf6e3;color:#657b83;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#dc322f;">- pub fn create_syn(blank_syn: &amp;mut [u8], dest_ip: [u8; 4]) {
</span><span style="color:#dc322f;">-   blank_syn[30..34].copy_from_slice(&amp;dest_ip);
</span><span style="color:#dc322f;">-   calculate_checksums(blank_syn);
</span><span style="color:#dc322f;">- }
</span><span>
</span><span style="color:#859900;">+ pub fn create_tcp_packet(blank_packet: &amp;mut [u8], dest_ip: [u8; 4]) {
</span><span style="color:#859900;">+   blank_packet[30..34].copy_from_slice(&amp;dest_ip);
</span><span style="color:#859900;">+   calculate_checksums(blank_packet);
</span><span style="color:#859900;">+ }
</span></code></pre>
<p>Finally, send an ACK in response to SYN-ACKs</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">if </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span>(packet) = packet {
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">type: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.packet_type);
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">ip: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.ip);
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">port: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.port);
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">seq: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.sequence_number);
</span><span>
</span><span>    </span><span style="color:#859900;">if</span><span> packet.packet_type == ServerPacketType::SynAck {
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ack = blank_ack;
</span><span>        </span><span style="color:#93a1a1;">// Copy the sequence number from the SYN-ACK packet for the acknowledgement
</span><span>        ack[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(packet.sequence_number + </span><span style="color:#6c71c4;">1</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>        tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> ack, packet.ip);
</span><span>        socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>ack, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>            .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>Let's see if it works with <code>tcpdump</code>...</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ sudo tcpdump -vennSxs 0 tcp and host 1.1.1.1
</span><span>tcpdump: listening on wlan0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
</span><span>17:33:30.038122 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 54: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 40)
</span><span>    192.168.50.161.65535 &gt; 1.1.1.1.443: Flags [S], cksum 0xbdeb (correct), seq 0, win 64240, length 0
</span><span>    0x0000:  4500 0028 0000 0000 4006 8585 c0a8 32a1
</span><span>    0x0010:  0101 0101 ffff 01bb 0000 0000 0000 0000
</span><span>    0x0020:  5002 faf0 bdeb 0000
</span><span>17:33:30.043740 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 60: (tos 0x0, ttl 57, id 0, offset 0, flags [DF], proto TCP (6), length 44)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.65535: Flags [S.], cksum 0x51cc (correct), seq 1220807574, ack 1, win 64240, options [mss 1452], length 0
</span><span>    0x0000:  4500 002c 0000 4000 3906 4c81 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb ffff 48c4 0b96 0000 0001
</span><span>        0x0020:  6012 faf0 51cc 0000 0204 05ac 0000
</span><span>17:33:30.043838 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 54: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 40)
</span><span>    192.168.50.161.65535 &gt; 1.1.1.1.443: Flags [.], cksum 0x6980 (correct), ack 1220807575, win 64240, length 0
</span><span>    0x0000:  4500 0028 0000 0000 4006 8585 c0a8 32a1
</span><span>    0x0010:  0101 0101 ffff 01bb 0000 0002 48c4 0b97
</span><span>    0x0020:  5010 faf0 6980 0000
</span><span>^C
</span><span>3 packets captured
</span><span>3 packets received by filter
</span><span>0 packets dropped by kernel
</span></code></pre>
<p>It does! Nothing happens after, which is a good thing. The server is waiting for us to send data after the connection has been established. Also, unlike last time, there weren't any double SYN-ACKs from the server, so I'm assuming 1.1.1.1 sends another SYN-ACK if it hasn't received an ACK in a while to make sure the packet hasn't been lost. In fact, we can observe the reverse if we send two SYNs with the same data:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>syn, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty()).</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span></code></pre>
<p>This will cause the server to only send back one SYN-ACK if we respond with an ACK quickly enough, as it's assuming we're doing the same thing and sending two SYNs for redundancy.</p>
<p><hr data-content="the most convoluted HTTP GETter, but it actually works now" \>
For a final test of our basic TCP implementation, let's send some data after our ACK. First, let's define what we'll send (an HTTP GET request to 1.1.1.1)</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> payload = </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">GET / HTTP/1.1</span><span style="color:#dc322f;">\n</span><span style="color:#2aa198;">Host: 1.1.1.1</span><span style="color:#dc322f;">\n\n</span><span style="color:#839496;">&quot;</span><span>;
</span></code></pre>
<p>Since we modify our ACK packet before sending it by changing the checksum, and the checksum function assumes the checksum field is blank, we'll need to create another copy of the blank ACK before applying the checksum:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">if</span><span> packet.packet_type == ServerPacketType::SynAck {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data = blank_ack;
</span><span>    </span><span style="color:#93a1a1;">// Copy the sequence number from the SYN-ACK packet for the acknowledgement
</span><span>    data[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(packet.sequence_number + </span><span style="color:#6c71c4;">1</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>    
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ack = data;
</span><span>    tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> ack, packet.ip);
</span><span>    socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>ack, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>        .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> payload = </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">GET / HTTP/1.1</span><span style="color:#dc322f;">\n</span><span style="color:#2aa198;">Host: 1.1.1.1</span><span style="color:#dc322f;">\n\n</span><span style="color:#839496;">&quot;</span><span>;
</span><span>
</span><span>}
</span></code></pre>
<p>Notice how the data's acknowledgement number is the same as the ACKs - this is because the acknowledgement number identifies the last packet received, which will be the same packet if we send two packets in a row.</p>
<p>The only differences between the ACK and the data are:</p>
<ul>
<li>the payload attached to the end</li>
<li>the length field of the IP header being longer</li>
<li>the PSH flag is set, which tells the kernel on the server to immediately send the data to whatever the application that is bound to that port is</li>
</ul>
<p>So we just need to change these fields, then we can send our data packet</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">if </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span>(packet) = packet {
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">type: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.packet_type);
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">ip: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.ip);
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">port: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.port);
</span><span>    </span><span style="color:#859900;">println!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">seq: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span>, packet.sequence_number);
</span><span>
</span><span>    </span><span style="color:#859900;">if</span><span> packet.packet_type == ServerPacketType::SynAck {
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data = blank_ack;
</span><span>        </span><span style="color:#93a1a1;">// Copy the sequence number from the SYN-ACK packet for the acknowledgement
</span><span>        data[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(packet.sequence_number + </span><span style="color:#6c71c4;">1</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ack = data;
</span><span>        tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> ack, packet.ip);
</span><span>        socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>ack, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>            .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#93a1a1;">// new!
</span><span>        </span><span style="color:#268bd2;">let</span><span> payload = </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">GET / HTTP/1.1</span><span style="color:#dc322f;">\n</span><span style="color:#2aa198;">Host: 1.1.1.1</span><span style="color:#dc322f;">\n\n</span><span style="color:#839496;">&quot;</span><span>;
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data = data.</span><span style="color:#859900;">to_vec</span><span>();
</span><span>        data.</span><span style="color:#859900;">extend</span><span>(payload.</span><span style="color:#859900;">as_bytes</span><span>());
</span><span>        </span><span style="color:#93a1a1;">// Update length
</span><span>        data[</span><span style="color:#6c71c4;">16</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">18</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(</span><span style="color:#6c71c4;">40 </span><span>+ payload.</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>        </span><span style="color:#93a1a1;">// Set TCP flags to ACK (16) and PSH (8)
</span><span>        data[</span><span style="color:#6c71c4;">47</span><span>] = </span><span style="color:#6c71c4;">16 </span><span style="color:#859900;">| </span><span style="color:#6c71c4;">8</span><span>;
</span><span>        tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> data, packet.ip);
</span><span>        socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>data, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>            .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>Let's run it and see what <code>tcpdump</code> says:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>‚ùØ sudo tcpdump -vennSxs 0 tcp and host 1.1.1.1
</span><span>tcpdump: listening on wlan0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
</span><span>19:28:42.784289 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 54: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 40)
</span><span>    192.168.50.161.65535 &gt; 1.1.1.1.443: Flags [S], cksum 0xbdeb (correct), seq 0, win 64240, length 0
</span><span>    0x0000:  4500 0028 0000 0000 4006 8585 c0a8 32a1
</span><span>    0x0010:  0101 0101 ffff 01bb 0000 0000 0000 0000
</span><span>    0x0020:  5002 faf0 bdeb 0000
</span><span>19:28:42.791441 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 60: (tos 0x0, ttl 57, id 0, offset 0, flags [DF], proto TCP (6), length 44)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.65535: Flags [S.], cksum 0x1300 (correct), seq 1858217060, ack 1, win 64240, options [mss 1452], length 0
</span><span>    0x0000:  4500 002c 0000 4000 3906 4c81 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb ffff 6ec2 2464 0000 0001
</span><span>    0x0020:  6012 faf0 1300 0000 0204 05ac 0000
</span><span>19:28:42.791578 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 54: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 40)
</span><span>    192.168.50.161.65535 &gt; 1.1.1.1.443: Flags [.], cksum 0x2ab5 (correct), ack 1858217061, win 64240, length 0
</span><span>    0x0000:  4500 0028 0000 0000 4006 8585 c0a8 32a1
</span><span>    0x0010:  0101 0101 ffff 01bb 0000 0001 6ec2 2465
</span><span>    0x0020:  5010 faf0 2ab5 0000
</span><span>19:28:42.791612 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 84: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 70)
</span><span>    192.168.50.161.65535 &gt; 1.1.1.1.443: Flags [P.], cksum 0xc33d (correct), seq 1:31, ack 1858217061, win 64240, length 30
</span><span>    0x0000:  4500 0046 0000 0000 4006 8567 c0a8 32a1
</span><span>    0x0010:  0101 0101 ffff 01bb 0000 0001 6ec2 2465
</span><span>    0x0020:  5018 faf0 c33d 0000 4745 5420 2f20 4854
</span><span>    0x0030:  5450 2f31 2e31 0a48 6f73 743a 2031 2e31
</span><span>    0x0040:  2e31 2e31 0a0a
</span><span>19:28:42.799292 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 60: (tos 0x0, ttl 57, id 32422, offset 0, flags [DF], proto TCP (6), length 40)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.65535: Flags [.], cksum 0x2c5f (correct), ack 31, win 63784, length 0
</span><span>    0x0000:  4500 0028 7ea6 4000 3906 cdde 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb ffff 6ec2 2465 0000 001f
</span><span>    0x0020:  5010 f928 2c5f 0000 0000 0000 0000
</span><span>19:28:42.799747 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 468: (tos 0x0, ttl 57, id 32423, offset 0, flags [DF], proto TCP (6), length 454)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.65535: Flags [P.], cksum 0x894e (correct), seq 1858217061:1858217475, ack 31, win 63784, length 414
</span><span>    0x0000:  4500 01c6 7ea7 4000 3906 cc3f 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb ffff 6ec2 2465 0000 001f
</span><span>    0x0020:  5018 f928 894e 0000 4854 5450 2f31 2e31
</span><span>    0x0030:  2034 3030 2042 6164 2052 6571 7565 7374
</span><span>    0x0040:  0d0a 5365 7276 6572 3a20 636c 6f75 6466
</span><span>    0x0050:  6c61 7265 0d0a 4461 7465 3a20 5765 642c
</span><span>    0x0060:  2031 3220 4a75 6c20 3230 3233 2032 333a
</span><span>    0x0070:  3238 3a34 3220 474d 540d 0a43 6f6e 7465
</span><span>    0x0080:  6e74 2d54 7970 653a 2074 6578 742f 6874
</span><span>    0x0090:  6d6c 0d0a 436f 6e74 656e 742d 4c65 6e67
</span><span>    0x00a0:  7468 3a20 3235 330d 0a43 6f6e 6e65 6374
</span><span>    0x00b0:  696f 6e3a 2063 6c6f 7365 0d0a 4346 2d52
</span><span>    0x00c0:  4159 3a20 2d0d 0a0d 0a3c 6874 6d6c 3e0d
</span><span>    0x00d0:  0a3c 6865 6164 3e3c 7469 746c 653e 3430
</span><span>    0x00e0:  3020 5468 6520 706c 6169 6e20 4854 5450
</span><span>    0x00f0:  2072 6571 7565 7374 2077 6173 2073 656e
</span><span>    0x0100:  7420 746f 2048 5454 5053 2070 6f72 743c
</span><span>    0x0110:  2f74 6974 6c65 3e3c 2f68 6561 643e 0d0a
</span><span>    0x0120:  3c62 6f64 793e 0d0a 3c63 656e 7465 723e
</span><span>    0x0130:  3c68 313e 3430 3020 4261 6420 5265 7175
</span><span>    0x0140:  6573 743c 2f68 313e 3c2f 6365 6e74 6572
</span><span>    0x0150:  3e0d 0a3c 6365 6e74 6572 3e54 6865 2070
</span><span>    0x0160:  6c61 696e 2048 5454 5020 7265 7175 6573
</span><span>    0x0170:  7420 7761 7320 7365 6e74 2074 6f20 4854
</span><span>    0x0180:  5450 5320 706f 7274 3c2f 6365 6e74 6572
</span><span>    0x0190:  3e0d 0a3c 6872 3e3c 6365 6e74 6572 3e63
</span><span>    0x01a0:  6c6f 7564 666c 6172 653c 2f63 656e 7465
</span><span>    0x01b0:  723e 0d0a 3c2f 626f 6479 3e0d 0a3c 2f68
</span><span>    0x01c0:  746d 6c3e 0d0a
</span><span>(this gets repeated for a while)
</span></code></pre>
<p>It seems that we are getting an HTTP response from out GET request. Let's see what the hex says...</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>HTTP/1.1 400 Bad Request
</span><span>Server: cloudflare
</span><span>Date: Wed, 12 Jul 2023 23:28:42 GMT
</span><span>Content-Type: text/html
</span><span>Content-Length: 253
</span><span>Connection: close
</span><span>CF-RAY: -
</span><span>
</span><span>&lt;html&gt;
</span><span>&lt;head&gt;&lt;title&gt;400 The plain HTTP request was sent to HTTPS port&lt;/title&gt;&lt;/head&gt;
</span><span>&lt;body&gt;
</span><span>&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;
</span><span>&lt;center&gt;The plain HTTP request was sent to HTTPS port&lt;/center&gt;
</span><span>&lt;hr&gt;&lt;center&gt;cloudflare&lt;/center&gt;
</span><span>&lt;/body&gt;
</span><span>&lt;/html&gt;
</span></code></pre>
<p>It seems to have worked! Let's check in with our program's output. Recall that it should print out the bytes of the enum variant <code>ServerPacketType::Data</code></p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>type: SynAck
</span><span>ip: [1, 1, 1, 1]
</span><span>port: [1, 187]
</span><span>seq: 1858217060
</span><span>^C‚èé
</span></code></pre>
<p>Odd. All it outputs is the SYN-ACK, then keeps hanging forever.</p>
<p><hr data-content="a confession" \>
So, if you look at the <code>tcpdump</code> output above closely, you may notice that the server ACKs 31 after we send our GET request. Earlier, I said that the server ACK will always be 2 after we send the first ACK. That isn't necessarily true - the sequence number adds <em>the TCP payload length</em> to the received sequence number. This is what the seuqnece number of 1:31 means, and why the server responded with an acknowledgement number of 31 (because the GET request is 30 bytes long). Thus, checking the acknowledgement number won't work, and the code needs to do it in the more proper way of checking the TCP flags.</p>
<p>So, back to <code>parse_server_packet</code>:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> acknowledgement_number = </span><span style="color:#268bd2;">u32</span><span>::from_be_bytes(
</span><span>    server_packet[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>]
</span><span>        .</span><span style="color:#859900;">try_into</span><span>()
</span><span>        .</span><span style="color:#859900;">expect</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">42..46 should be [u8; 4]</span><span style="color:#839496;">&quot;</span><span>),
</span><span>);
</span><span style="color:#268bd2;">let</span><span> packet_type = </span><span style="color:#859900;">match</span><span> acknowledgement_number {
</span><span>    </span><span style="color:#6c71c4;">1 </span><span style="color:#859900;">=&gt; Some</span><span>(ServerPacketType::SynAck),
</span><span>    </span><span style="color:#6c71c4;">3 </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data_offset = server_packet[</span><span style="color:#6c71c4;">46</span><span>] </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span>;
</span><span>        data_offset &gt;&gt;= </span><span style="color:#6c71c4;">4</span><span>;
</span><span>
</span><span>        </span><span style="color:#859900;">if</span><span> server_packet.</span><span style="color:#859900;">len</span><span>() &lt; </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset {
</span><span>            </span><span style="color:#859900;">return None</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#859900;">Some</span><span>(ServerPacketType::Data(
</span><span>            server_packet[</span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">to_vec</span><span>(),
</span><span>        ))
</span><span>    }
</span><span>    </span><span style="color:#859900;">_ =&gt; None</span><span>,
</span><span>}</span><span style="color:#859900;">?</span><span>;
</span></code></pre>
<p>Let's change this to match flags instead:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">SYN_ACK</span><span>: </span><span style="color:#268bd2;">u8 </span><span>= </span><span style="color:#6c71c4;">2 </span><span style="color:#859900;">| </span><span style="color:#6c71c4;">16</span><span>;
</span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">PSH_ACK</span><span>: </span><span style="color:#268bd2;">u8 </span><span>= </span><span style="color:#6c71c4;">8 </span><span style="color:#859900;">|</span><span style="color:#6c71c4;">16</span><span>;
</span><span>
</span><span style="color:#268bd2;">let</span><span> flags = server_packet[</span><span style="color:#6c71c4;">47</span><span>];
</span><span style="color:#268bd2;">let</span><span> packet_type = </span><span style="color:#859900;">match</span><span> flags {
</span><span>    </span><span style="color:#cb4b16;">SYN_ACK </span><span style="color:#859900;">=&gt; Some</span><span>(ServerPacketType::SynAck),
</span><span>    </span><span style="color:#cb4b16;">PSH_ACK </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data_offset = server_packet[</span><span style="color:#6c71c4;">46</span><span>] </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span>;
</span><span>        data_offset &gt;&gt;= </span><span style="color:#6c71c4;">4</span><span>;
</span><span>
</span><span>        </span><span style="color:#859900;">if</span><span> server_packet.</span><span style="color:#859900;">len</span><span>() &lt; </span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset {
</span><span>            </span><span style="color:#859900;">return None</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#859900;">Some</span><span>(ServerPacketType::Data(
</span><span>            server_packet[</span><span style="color:#cb4b16;">ETH_IP_HEADERS_LEN </span><span>+ data_offset</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">to_vec</span><span>(),
</span><span>        ))
</span><span>    }
</span><span>    </span><span style="color:#859900;">_ =&gt; None</span><span>,
</span><span>}</span><span style="color:#859900;">?</span><span>;
</span></code></pre>
<p>Also, the output of <code>tcpdump</code> shows the server continuously sending the response and trying to close the connection, because we haven't ACKed their data yet. Additionally, in the real application, leaving a half-open connection would be pretty rude to the servers we're scanning for Minecraft servers. Let's fix that by sending a packet with an RST flag (meaning reset, or abruptly terminating a connection without doing a 4-way FIN handshake) to the server. We need to send both RST and ACK or servers may think we made a mistake, and will keep trying to push data to us for a while.</p>
<p>Back in main.rs, let's change the <code>if packet.packet_type = ServerPacketType::SynAck</code> into a match statement:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">match</span><span> packet.packet_type {
</span><span>    ServerPacketType::SynAck </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data = blank_ack;
</span><span>        </span><span style="color:#93a1a1;">// Copy the sequence number from the SYN-ACK packet for the acknowledgement
</span><span>        data[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(packet.sequence_number + </span><span style="color:#6c71c4;">1</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ack = data;
</span><span>        tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> ack, packet.ip);
</span><span>        socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>ack, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>            .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> data = data.</span><span style="color:#859900;">to_vec</span><span>();
</span><span>        data.</span><span style="color:#859900;">extend</span><span>(payload.</span><span style="color:#859900;">as_bytes</span><span>());
</span><span>        </span><span style="color:#93a1a1;">// Update length
</span><span>        data[</span><span style="color:#6c71c4;">16</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">18</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(</span><span style="color:#6c71c4;">40 </span><span>+ payload.</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>        </span><span style="color:#93a1a1;">// Set TCP flags to ACK (16) and PSH (8)
</span><span>        data[</span><span style="color:#6c71c4;">47</span><span>] = </span><span style="color:#6c71c4;">16 </span><span style="color:#859900;">| </span><span style="color:#6c71c4;">8</span><span>;
</span><span>        tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> data, packet.ip);
</span><span>        socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>data, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>            .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>    },
</span><span>}
</span></code></pre>
<p>And now, let's add a branch for <code>ServerPacketType::Data</code> that will send a RST</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>ServerPacketType::Data(data) </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> reset = blank_syn;
</span><span>    </span><span style="color:#93a1a1;">// Set TCP flags to RST and ACK
</span><span>    reset[</span><span style="color:#6c71c4;">47</span><span>] = </span><span style="color:#6c71c4;">4 </span><span style="color:#859900;">| </span><span style="color:#6c71c4;">16</span><span>;
</span><span>    </span><span style="color:#93a1a1;">// Sequence number should be previous sequence number (1) + payload length
</span><span>    reset[</span><span style="color:#6c71c4;">38</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">42</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(</span><span style="color:#6c71c4;">1 </span><span>+ payload.</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u32</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>    </span><span style="color:#93a1a1;">// Acknowledgement number should be server sequence number + server data length
</span><span>    reset[</span><span style="color:#6c71c4;">42</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">46</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(packet.sequence_number + data.</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u32</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>    tcp::create_tcp_packet(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> reset, packet.ip);
</span><span>    socket::sendto(socket, </span><span style="color:#859900;">&amp;</span><span>reset, </span><span style="color:#859900;">&amp;</span><span>bind_addr, MsgFlags::empty())
</span><span>        .</span><span style="color:#859900;">context</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Socket send failed</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>;
</span><span>},
</span></code></pre>
<p>Let's run it and see what <code>tcpdump</code> has to say:</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>(truncated)
</span><span>    0x00e0:  3020 5468 6520 706c 6169 6e20 4854 5450
</span><span>    0x00f0:  2072 6571 7565 7374 2077 6173 2073 656e
</span><span>    0x0100:  7420 746f 2048 5454 5053 2070 6f72 743c
</span><span>    0x0110:  2f74 6974 6c65 3e3c 2f68 6561 643e 0d0a
</span><span>    0x0120:  3c62 6f64 793e 0d0a 3c63 656e 7465 723e
</span><span>    0x0130:  3c68 313e 3430 3020 4261 6420 5265 7175
</span><span>    0x0140:  6573 743c 2f68 313e 3c2f 6365 6e74 6572
</span><span>    0x0150:  3e0d 0a3c 6365 6e74 6572 3e54 6865 2070
</span><span>    0x0160:  6c61 696e 2048 5454 5020 7265 7175 6573
</span><span>    0x0170:  7420 7761 7320 7365 6e74 2074 6f20 4854
</span><span>    0x0180:  5450 5320 706f 7274 3c2f 6365 6e74 6572
</span><span>    0x0190:  3e0d 0a3c 6872 3e3c 6365 6e74 6572 3e63
</span><span>    0x01a0:  6c6f 7564 666c 6172 653c 2f63 656e 7465
</span><span>    0x01b0:  723e 0d0a 3c2f 626f 6479 3e0d 0a3c 2f68
</span><span>    0x01c0:  746d 6c3e 0d0a
</span><span>20:11:04.763877 04:d4:c4:1a:0b:a8 &gt; b0:7d:64:57:83:84, ethertype IPv4 (0x0800), length 60: (tos 0x0, ttl 57, id 16902, offset 0, flags [DF], proto TCP (6), length 40)
</span><span>    1.1.1.1.443 &gt; 192.168.50.161.65535: Flags [F.], cksum 0xad91 (correct), seq 2921751501, ack 31, win 63784, length 0
</span><span>    0x0000:  4500 0028 4206 4000 3906 0a7f 0101 0101
</span><span>    0x0010:  c0a8 32a1 01bb ffff ae26 63cd 0000 001f
</span><span>    0x0020:  5011 f928 ad91 0000 0000 0000 0000
</span><span>20:11:04.763958 b0:7d:64:57:83:84 &gt; 04:d4:c4:1a:0b:a8, ethertype IPv4 (0x0800), length 54: (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto TCP (6), length 40)
</span><span>    192.168.50.161.65535 &gt; 1.1.1.1.443: Flags [R.], cksum 0xabb7 (correct), seq 31, ack 2921751516, win 64240, length 0
</span><span>    0x0000:  4500 0028 0000 0000 4006 8585 c0a8 32a1
</span><span>    0x0010:  0101 0101 ffff 01bb 0000 001f ae26 63dc
</span><span>    0x0020:  5014 faf0 abb7 0000
</span><span>(nothing else happens)
</span></code></pre>
<p>Great! The server has received our RST packet and is not continuing to send us data. And do we get data output on our program this time?</p>
<pre style="background-color:#fdf6e3;color:#657b83;"><code><span>type: SynAck
</span><span>ip: [1, 1, 1, 1]
</span><span>port: [1, 187]
</span><span>seq: 2921751086
</span><span>type: Data([38, 98, 47, 0, 0, 0, 31, 80, 24, 249, 40, 255, 41, 0, 0, 72, 84, 84, 80, 47, 49, 46, 49, 32, 52, 48, 48, 32, 66, 97, 100, 32, 82, 101, 113, 117, 101, 115, 116, 13, 10, 83, 101, 114, 118, 101, 114, 58, 32, 99, 108, 111, 117, 100, 102, 108, 97, 114, 101, 13, 10, 68, 97, 116, 101, 58, 32, 84, 104, 117, 44, 32, 49, 51, 32, 74, 117, 108, 32, 50, 48, 50, 51, 32, 48, 48, 58, 49, 49, 58, 48, 52, 32, 71, 77, 84, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 32, 116, 101, 120, 116, 47, 104, 116, 109, 108, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 76, 101, 110, 103, 116, 104, 58, 32, 50, 53, 51, 13, 10, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 58, 32, 99, 108, 111, 115, 101, 13, 10, 67, 70, 45, 82, 65, 89, 58, 32, 45, 13, 10, 13, 10, 60, 104, 116, 109, 108, 62, 13, 10, 60, 104, 101, 97, 100, 62, 60, 116, 105, 116, 108, 101, 62, 52, 48, 48, 32, 84, 104, 101, 32, 112, 108, 97, 105, 110, 32, 72, 84, 84, 80, 32, 114, 101, 113, 117, 101, 115, 116, 32, 119, 97, 115, 32, 115, 101, 110, 116, 32, 116, 111, 32, 72, 84, 84, 80, 83, 32, 112, 111, 114, 116, 60, 47, 116, 105, 116, 108, 101, 62, 60, 47, 104, 101, 97, 100, 62, 13, 10, 60, 98, 111, 100, 121, 62, 13, 10, 60, 99, 101, 110, 116, 101, 114, 62, 60, 104, 49, 62, 52, 48, 48, 32, 66, 97, 100, 32, 82, 101, 113, 117, 101, 115, 116, 60, 47, 104, 49, 62, 60, 47, 99, 101, 110, 116, 101, 114, 62, 13, 10, 60, 99, 101, 110, 116, 101, 114, 62, 84, 104, 101, 32, 112, 108, 97, 105, 110, 32, 72, 84, 84, 80, 32, 114, 101, 113, 117, 101, 115, 116, 32, 119, 97, 115, 32, 115, 101, 110, 116, 32, 116, 111, 32, 72, 84, 84, 80, 83, 32, 112, 111, 114, 116, 60, 47, 99, 101, 110, 116, 101, 114, 62, 13, 10, 60, 104, 114, 62, 60, 99, 101, 110, 116, 101, 114, 62, 99, 108, 111, 117, 100, 102, 108, 97, 114, 101, 60, 47, 99, 101, 110, 116, 101, 114, 62, 13, 10, 60, 47, 98, 111, 100, 121, 62, 13, 10, 60, 47, 104, 116, 109, 108, 62, 13, 10])
</span><span>ip: [1, 1, 1, 1]
</span><span>port: [1, 187]
</span><span>seq: 2921751087
</span></code></pre>
<p>Yes we do!</p>
<p>Now that we can make TCP connections and send/receive data, we'll need to implement the other part of our minecraft server scanner - mass scanning servers through spamming SYNs.</p>
<p><hr data-content="i love spamming" \>
We can copy masscan's architecture for the SYN flood/mass scanning part. Masscan uses a thread to continuously send SYNs to all the hosts we want to scan, and another thread for receiving data. In pseudocode, the scan thread may look like this:</p>
<pre data-lang="python" style="background-color:#fdf6e3;color:#657b83;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#268bd2;">EXCLUDE_LIST </span><span>= </span><span style="color:#859900;">input</span><span>()
</span><span style="color:#268bd2;">IP_LIST </span><span>= [[i, j, k, l] </span><span style="color:#859900;">for </span><span>l </span><span style="color:#859900;">in range</span><span>(</span><span style="color:#6c71c4;">256</span><span>) </span><span style="color:#859900;">for </span><span>k </span><span style="color:#859900;">in range</span><span>(</span><span style="color:#6c71c4;">256</span><span>) </span><span style="color:#859900;">for </span><span>j </span><span style="color:#859900;">in range</span><span>(</span><span style="color:#6c71c4;">256</span><span>) </span><span style="color:#859900;">for </span><span>i </span><span style="color:#859900;">in range</span><span>(</span><span style="color:#6c71c4;">256</span><span>)] </span><span style="color:#859900;">and not </span><span style="color:#268bd2;">EXCLUDE_LIST
</span><span>
</span><span style="color:#859900;">for </span><span>ip </span><span style="color:#859900;">in </span><span style="color:#268bd2;">IP_LIST</span><span>:
</span><span>    </span><span style="color:#b58900;">send_syn</span><span>(ip)
</span></code></pre>
<p>However, there are two problems with this. One is immediately obvious - an IPv4 address is 32 bits, so there are 2^32 possible IPs taking 4 bytes each. Doing the math, this will take 16 GB to store, and it has to fit in RAM. Using <a href="https://rust-script.org/">rust-script</a> to make the list of all IPs, it indeed crashes:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>‚ùØ rust-script -e </span><span style="color:#586e75;">&#39;let mut</span><span> v = </span><span style="color:#859900;">vec!</span><span>[]; </span><span style="color:#859900;">for</span><span> i </span><span style="color:#859900;">in </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">256 </span><span>{ </span><span style="color:#859900;">for</span><span> j </span><span style="color:#859900;">in </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">256 </span><span>{ </span><span style="color:#859900;">for</span><span> k </span><span style="color:#859900;">in </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">256 </span><span>{ </span><span style="color:#859900;">for</span><span> l </span><span style="color:#859900;">in </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">256 </span><span>{ v.</span><span style="color:#859900;">push</span><span>([i,j,k,l]); } } } }</span><span style="color:#859900;">&#39;
</span><span>
</span><span>fish: Job </span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#586e75;">&#39;rust</span><span>-script -e </span><span style="color:#586e75;">&#39;let mut</span><span> v = vec‚Ä¶</span><span style="color:#859900;">&#39;</span><span> terminated by signal </span><span style="color:#cb4b16;">SIGKILL </span><span>(Forced quit)
</span></code></pre>
<p>The solution masscan uses is to construct ranges of IPs from all the IPs not in the exclude list, and calculate an IP from an index. For example, if the range is all IP addresses, and the index is 32, the program would calculate the 32nd IP address and send a SYN to that. Here's the second problem: IP addresses &quot;close&quot; to each other tend to be owned by the same organization, or even running on the same server. For example, the CIDR range 8.0.0.0/8 is owned by the US military. It would certainly scare some organizations if they received many SYNs on all their IPs at once, as it would look like an attack and might get us blocked for spam. Thus, we need to randomize the IPs in the range. Masscan uses a modified version of the DES encryption algorithm called Blackrock that can make a <a href="https://en.wikipedia.org/wiki/Bijection">one-to-one</a> mapping of indices For example, if you had the numbers 0-65535 in order and passed each number to Blackrock you'd get a list of the exact same numbers but in a random order. This allows for randomly shuffling IPs with our calculate-IPs-from-indices strategy, without storing every IP in memory and randomizing it there.</p>
<p>I have no clue how any encryption algorithm works, but fortunately for me, mat-1 has already <a href="https://github.com/mat-1/perfect_rand">ported it</a> to Rust! (On the off-chance that you're reading this mat, you probably don't know who I am but you're such an inspiration to me üíñ)</p>
<p>Let's <del>steal</del> add his crate for later:</p>
<pre data-lang="toml" style="background-color:#fdf6e3;color:#657b83;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#268bd2;">perfect_rand </span><span>= { </span><span style="color:#268bd2;">git </span><span>= </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">https://github.com/mat-1/perfect_rand/</span><span style="color:#839496;">&quot;</span><span>, </span><span style="color:#268bd2;">rev </span><span>= </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">725343f</span><span style="color:#839496;">&quot; </span><span>}
</span></code></pre>
<p><hr data-content="exclude ranges - promise this isn&#x27;t more bikeshedding" \>
To implement the exclude ranges, let's recap on the algorithm. First, convert ranges of IPs to exclude/scan into ranges of integers. (since an IPv4 address can fit into a 32 bit integer) Then:</p>
<ol>
<li>Trim down the range of IPs to scan (without excludes) by checking each exclusion range to see if it starts outside the range and ends inside it, or if it starts within the range and ends outside it.
<img class="invertable" src="&#x2F;images&#x2F;ranges_trimming_sides.png" alt="Trimming the sides of the IP range with the exclusion ranges" /></li>
<li>Keep doing this until there's nothing left to trim. (ty RShields for pointing out that this is possible)</li>
<li>Find a range of excluded IPs that is completely inside the range of IPs to scan after trimming. (i.e. the exclusion range starts after the scanning range and ends before the scanning range) Split the scanning range using this exclusion range and start from step 1 on both of the resulting ranges.
<img class="invertable" src="&#x2F;images&#x2F;range_split_inside.png" alt="Splitting the scanning range by an exclusion range inside it" /></li>
</ol>
<p>Hope that wasn't too confusing! I think this algorithm is O(n^2), which isn't ideal. However, since this only runs once at the start of the program, performance isn't as big of an issue. An faster alternative was suggested by RShields (tysm ily ‚ù§) but I didn't end up using that.
<img src="/images/rshields_splitting_algorithm.png" alt="RShields the based CS overlord" /></p>
<p>Let's start implementing the algorithm by moving the <code>ExcludedIps</code> struct to a new file:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">// excludes.rs
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug)]
</span><span style="color:#93a1a1;">/// IPs to be excluded from a scan
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">ExcludedIps </span><span>{
</span><span>    Cidr(Ipv4Addr, </span><span style="color:#268bd2;">u8</span><span>),
</span><span>    Range(Ipv4Addr, Ipv4Addr),
</span><span>    Address(Ipv4Addr),
</span><span>}
</span></code></pre>
<p>Now, let's define a <code>Range</code> struct and convert parsed IP exclusions to it:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Clone, Copy)]
</span><span style="color:#93a1a1;">/// Inclusive range, start always &lt;= end
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">Range </span><span>{
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">start</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">end</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>}
</span><span>
</span><span style="color:#268bd2;">impl </span><span style="color:#b58900;">ExcludedIps </span><span>{
</span><span>    </span><span style="color:#93a1a1;">/// Convert excluded IPs to a range of IPs
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">to_range</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">self</span><span>) -&gt; Range {
</span><span>        </span><span style="color:#859900;">match </span><span>*</span><span style="color:#d33682;">self </span><span>{
</span><span>            ExcludedIps::Cidr(ip, mask) </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>                </span><span style="color:#268bd2;">let</span><span> mask = (</span><span style="color:#6c71c4;">1 </span><span>&lt;&lt; (</span><span style="color:#6c71c4;">32 </span><span>- mask)) -</span><span style="color:#6c71c4;">1</span><span>;
</span><span>                </span><span style="color:#268bd2;">let</span><span> start = </span><span style="color:#268bd2;">u32</span><span>::from(ip) </span><span style="color:#859900;">&amp; !</span><span>(mask);
</span><span>                </span><span style="color:#268bd2;">let</span><span> end = start + mask;
</span><span>                Range { start, end }
</span><span>            }
</span><span>            ExcludedIps::Range(ip1, ip2) </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>                </span><span style="color:#268bd2;">let</span><span> ip1 = </span><span style="color:#268bd2;">u32</span><span>::from(ip1);
</span><span>                </span><span style="color:#268bd2;">let</span><span> ip2 = </span><span style="color:#268bd2;">u32</span><span>::from(ip2);
</span><span>                </span><span style="color:#268bd2;">let</span><span> start = cmp::min(ip1, ip2);
</span><span>                </span><span style="color:#268bd2;">let</span><span> end = cmp::max(ip1, ip2);
</span><span>                Range { start, end }
</span><span>            }
</span><span>            ExcludedIps::Address(ip) </span><span style="color:#859900;">=&gt; </span><span>{
</span><span>                </span><span style="color:#268bd2;">let</span><span> start = </span><span style="color:#268bd2;">u32</span><span>::from(ip);
</span><span>                </span><span style="color:#268bd2;">let</span><span> end = start;
</span><span>                Range { start, end }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Finally, we implement the algorithm discussed earlier.</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">impl </span><span style="color:#b58900;">Range </span><span>{
</span><span>    </span><span style="color:#93a1a1;">/// The ranges of IPs in this range that aren&#39;t in the list of exclusion ranges.
</span><span>    </span><span style="color:#93a1a1;">/// Note that the exclusions vector will be modified when running this method.
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">after_excludes</span><span>(</span><span style="color:#268bd2;">self</span><span>, </span><span style="color:#586e75;">mut </span><span style="color:#268bd2;">exclusions</span><span>: </span><span style="color:#859900;">Vec</span><span>&lt;Range&gt;) -&gt; </span><span style="color:#859900;">Vec</span><span>&lt;Range&gt; {
</span><span>        </span><span style="color:#859900;">if</span><span> exclusions.</span><span style="color:#859900;">is_empty</span><span>() {
</span><span>            </span><span style="color:#859900;">return vec!</span><span>[</span><span style="color:#d33682;">self</span><span>];
</span><span>        }
</span><span>
</span><span>
</span><span>        </span><span style="color:#93a1a1;">// Trim off exclusion at the edge of of this current range
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> current_range = </span><span style="color:#d33682;">self</span><span>;
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> fully_inside = </span><span style="color:#859900;">None</span><span>;
</span><span>
</span><span>        </span><span style="color:#93a1a1;">// As pointed out by RShields, we can do this multiple times
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> indices_to_remove = </span><span style="color:#859900;">Vec</span><span>::with_capacity(exclusions.</span><span style="color:#859900;">len</span><span>());
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> done_something = </span><span style="color:#b58900;">false</span><span>;
</span><span>        </span><span style="color:#859900;">loop </span><span>{
</span><span>            </span><span style="color:#859900;">for </span><span>(i, exclusion) </span><span style="color:#859900;">in</span><span> exclusions.</span><span style="color:#859900;">iter</span><span>().</span><span style="color:#859900;">enumerate</span><span>() {
</span><span>                </span><span style="color:#859900;">if</span><span> exclusion.start &lt;= current_range.start {
</span><span>                    current_range.start = cmp::max(current_range.start, exclusion.end + </span><span style="color:#6c71c4;">1</span><span>);
</span><span>                    indices_to_remove.</span><span style="color:#859900;">push</span><span>(i);
</span><span>                    done_something = </span><span style="color:#b58900;">true</span><span>;
</span><span>                }
</span><span>                </span><span style="color:#859900;">else if</span><span> exclusion.end &gt;= current_range.end {
</span><span>                    current_range.end = cmp::min(current_range.end, exclusion.start - </span><span style="color:#6c71c4;">1</span><span>);
</span><span>                    indices_to_remove.</span><span style="color:#859900;">push</span><span>(i);
</span><span>                    done_something = </span><span style="color:#b58900;">true</span><span>;
</span><span>                }
</span><span>                </span><span style="color:#859900;">else </span><span>{
</span><span>                    </span><span style="color:#93a1a1;">// The start of the exclusion and end of the exclusion are inside this range
</span><span>                    fully_inside = </span><span style="color:#859900;">Some</span><span>(*exclusion);
</span><span>                }
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#859900;">if !</span><span>done_something {
</span><span>                </span><span style="color:#859900;">break</span><span>;
</span><span>            }
</span><span>            done_something = </span><span style="color:#b58900;">false</span><span>;
</span><span>            </span><span style="color:#93a1a1;">// Reset because fully inside this time doesn&#39;t mean the same for next time
</span><span>            fully_inside = </span><span style="color:#859900;">None</span><span>;
</span><span>            </span><span style="color:#93a1a1;">// Has to be sorted for funky reasons don&#39;t question it
</span><span>            </span><span style="color:#93a1a1;">// Elements are added in ascending order (see above loop) so we flip it
</span><span>            indices_to_remove.</span><span style="color:#859900;">reverse</span><span>();
</span><span>            </span><span style="color:#859900;">for</span><span> index </span><span style="color:#859900;">in</span><span> indices_to_remove.</span><span style="color:#859900;">drain</span><span>(</span><span style="color:#859900;">..</span><span>) {
</span><span>                exclusions.</span><span style="color:#859900;">remove</span><span>(index);
</span><span>            }
</span><span>        }
</span><span>
</span><span>
</span><span>        </span><span style="color:#93a1a1;">// Split the range by any exclusion fully inside this range, if one exists
</span><span>        </span><span style="color:#93a1a1;">// Then do recursion
</span><span>        </span><span style="color:#859900;">if </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span>(exclusion) = fully_inside {
</span><span>            </span><span style="color:#268bd2;">let</span><span> split_range_one = Range {
</span><span>                start: current_range.start,
</span><span>                end: exclusion.start - </span><span style="color:#6c71c4;">1</span><span>,
</span><span>            };
</span><span>            </span><span style="color:#268bd2;">let</span><span> split_range_two = Range {
</span><span>                start: exclusion.end + </span><span style="color:#6c71c4;">1</span><span>,
</span><span>                end: current_range.end,
</span><span>            };
</span><span>
</span><span>            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ret = </span><span style="color:#859900;">Vec</span><span>::new();
</span><span>            ret.</span><span style="color:#859900;">append</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> split_range_one.</span><span style="color:#859900;">after_excludes</span><span>(exclusions.</span><span style="color:#859900;">clone</span><span>()));
</span><span>            ret.</span><span style="color:#859900;">append</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> split_range_two.</span><span style="color:#859900;">after_excludes</span><span>(exclusions.</span><span style="color:#859900;">clone</span><span>()));
</span><span>            ret
</span><span>        } </span><span style="color:#859900;">else </span><span>{
</span><span>            </span><span style="color:#93a1a1;">// Check for validity
</span><span>            </span><span style="color:#859900;">if</span><span> current_range.start &lt;= current_range.end {
</span><span>                </span><span style="color:#859900;">vec!</span><span>[current_range]
</span><span>            } </span><span style="color:#859900;">else </span><span>{
</span><span>                </span><span style="color:#859900;">vec!</span><span>[]
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Read through the code if you want, but it basically does what I described earlier. A lot of the checks and implementation details were wrong on my first attempt of implementing the range calculation algorithm. I (rightly) didn't trust myself to make a bug-free implementation on my first try. Fortunately, fuzzing can save my horrendous code.</p>
<p><hr data-content="fuzzing - okay maybe this is bikeshedding" \>
Fuzzing simply takes some random input data and tries it on a function to test for errors, and is used in many applications to automate the discovery of off-by-one errors, weird memory safety bugs, etc. Most fuzzers also have shrinking algorithms which, when they find a bug, find the smallest possible input that can reproduce that bug. The fuzzer I chose is the <code>proptest</code> crate, the most popular rust fuzzer currently. It can fuzz any function that takes in arguments of the <code>Arbitrary</code> trait, which converts any sequence of bytes to a struct. Let's derive it for a new <code>Range</code>- like object:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">cfg</span><span>(test)]
</span><span style="color:#268bd2;">mod </span><span style="color:#b58900;">test </span><span>{
</span><span>    </span><span style="color:#859900;">use super</span><span>::*;
</span><span>    </span><span style="color:#859900;">use </span><span>proptest::prelude::*;
</span><span>    </span><span style="color:#859900;">use </span><span>proptest_derive::Arbitrary;
</span><span>
</span><span>    #[</span><span style="color:#268bd2;">derive</span><span>(Arbitrary, Debug, Clone, Copy)]
</span><span>    </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">TestRange </span><span>{
</span><span>        </span><span style="color:#268bd2;">start</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>        </span><span style="color:#268bd2;">end</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    }
</span></code></pre>
<p><code>Arbitrary</code> is implemented for <code>Box&lt;[impl Arbitrary]&gt;</code> so we can use a <code>Box&lt;[TestRange]</code> for our excludes, and a regular <code>TestRange</code> for the range of IPs to test. We need the start of a range to be less than or equal to the end, which <code>TestRange</code> does not guarantee. Let's make sure that's the case first in our fuzzing function:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">proptest! </span><span>{
</span><span>    #[</span><span style="color:#268bd2;">test</span><span>]
</span><span>    </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">range_exclusion_correct</span><span>(</span><span style="color:#268bd2;">test_range</span><span>: TestRange, </span><span style="color:#268bd2;">exclusions</span><span>: </span><span style="color:#859900;">Box</span><span>&lt;[TestRange]&gt;) {
</span><span>        </span><span style="color:#268bd2;">let</span><span> range = Range {
</span><span>            start: cmp::min(test_range.start, test_range.end),
</span><span>            end: cmp::max(test_range.start, test_range.end),
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#268bd2;">let</span><span> exclusions: </span><span style="color:#859900;">Vec</span><span>&lt;Range&gt; = exclusions.</span><span style="color:#859900;">iter</span><span>().</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">test_range</span><span>| {
</span><span>            Range {
</span><span>                start: cmp::min(test_range.start, test_range.end),
</span><span>                end: cmp::max(test_range.start, test_range.end),
</span><span>            }
</span><span>        }).</span><span style="color:#859900;">collect</span><span>();
</span></code></pre>
<p>Now we just have to calculate the scanning range after excluded ranges have been applied, and panic if it's incorrect so <code>proptest</code> knows about it!</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">proptest! </span><span>{
</span><span>    #[</span><span style="color:#268bd2;">test</span><span>]
</span><span>    </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">range_exclusion_correct</span><span>(</span><span style="color:#268bd2;">test_range</span><span>: TestRange, </span><span style="color:#268bd2;">exclusions</span><span>: </span><span style="color:#859900;">Box</span><span>&lt;[TestRange]&gt;) {
</span><span>        </span><span style="color:#93a1a1;">// omitted
</span><span>        
</span><span>        </span><span style="color:#268bd2;">let</span><span> excluded_ranges = range.</span><span style="color:#859900;">after_excludes</span><span>(exclusions.</span><span style="color:#859900;">clone</span><span>());
</span><span>        </span><span style="color:#93a1a1;">// Test if exclusions are correct
</span><span>        </span><span style="color:#859900;">for</span><span> exclusion </span><span style="color:#859900;">in &amp;</span><span>exclusions {
</span><span>            </span><span style="color:#859900;">for</span><span> i </span><span style="color:#859900;">in </span><span>[exclusion.start, exclusion.end] { </span><span style="color:#93a1a1;">// Don&#39;t test everything for performance reasons
</span><span>                </span><span style="color:#859900;">if in_ranges</span><span>(i, </span><span style="color:#859900;">&amp;</span><span>excluded_ranges) {
</span><span>                    </span><span style="color:#859900;">panic!</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">range: {range:#?} - exclusions: {exclusions:#?} - i: {i} - excluded_ranges: {excluded_ranges:#?}</span><span style="color:#839496;">&quot;</span><span>);
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">in_ranges</span><span>(</span><span style="color:#268bd2;">i</span><span>: </span><span style="color:#268bd2;">u32</span><span>, </span><span style="color:#268bd2;">ranges</span><span>: </span><span style="color:#859900;">&amp;</span><span>[Range]) -&gt; </span><span style="color:#268bd2;">bool </span><span>{
</span><span>    ranges.</span><span style="color:#859900;">iter</span><span>().</span><span style="color:#859900;">any</span><span>(|</span><span style="color:#268bd2;">range</span><span>| i &gt;= range.start </span><span style="color:#859900;">&amp;&amp;</span><span> i &lt;= range.end)
</span><span>}
</span></code></pre>
<p>The fuzzing should run after a normal <code>cargo test</code>.</p>
<p><hr data-content="the minecraft protocol - can&#x27;t scan minecraft servers without it!" \>
The scanner in <code>main.rs</code> currently doesn't do much scanning at all - it just sends an HTTP request.
The minecraft protocol is documented by the community at <a href="https://wiki.vg/">wiki.vg</a> which says there two types of pings - 1.6 and below, and 1.7+ (after the netcode was rewritten to use netty).
Previous scanners seem to use the 1.7+ ping because most servers use it - however, taking advantage of diminishing returns from reducing round-trips after the one round trip forces us to deal with all sorts of complications, we can first send a 1.6 ping (which the wiki says all servers should respond to) then send a 1.7 ping latter.
So, let's implement 1.6 first:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>: [</span><span style="color:#268bd2;">u8</span><span>; </span><span style="color:#6c71c4;">26</span><span>] = [
</span><span>    </span><span style="color:#6c71c4;">0xfe</span><span>, </span><span style="color:#6c71c4;">0x01</span><span>, </span><span style="color:#6c71c4;">0xfa</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x0b</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x4d</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x43</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x7c</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x50</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x69</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>,
</span><span>    </span><span style="color:#6c71c4;">0x6e</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x67</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x48</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x6f</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>, </span><span style="color:#6c71c4;">0x73</span><span>, </span><span style="color:#6c71c4;">0x00</span><span>,
</span><span>];
</span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">PROTOCOL_VER_1_6</span><span>: </span><span style="color:#268bd2;">u16 </span><span>= </span><span style="color:#6c71c4;">76</span><span>;
</span><span>
</span><span style="color:#93a1a1;">// https://wiki.vg/Server_List_Ping#1.6
</span><span style="color:#93a1a1;">/// Builds a 1.6 or earlier legacy server list ping packet
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">construct_1_6_ping</span><span>(</span><span style="color:#268bd2;">hostname</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">str</span><span>, </span><span style="color:#268bd2;">port</span><span>: </span><span style="color:#268bd2;">u16</span><span>) -&gt; </span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt; {
</span><span>    </span><span style="color:#268bd2;">let</span><span> encoded_string = hostname
</span><span>        .</span><span style="color:#859900;">encode_utf16</span><span>()
</span><span>        .</span><span style="color:#859900;">flat_map</span><span>(|</span><span style="color:#268bd2;">unit</span><span>: </span><span style="color:#268bd2;">u16</span><span>| unit.</span><span style="color:#859900;">to_be_bytes</span><span>())
</span><span>        .collect::&lt;</span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt;&gt;();
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ping_vec: </span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt; =
</span><span>        </span><span style="color:#859900;">Vec</span><span>::with_capacity(</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + encoded_string.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">7</span><span>);
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// Header
</span><span>    ping_vec[</span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>()].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>);
</span><span>    </span><span style="color:#93a1a1;">// Length of rest of message: 7 + len(hostname)
</span><span>    ping_vec[</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>()</span><span style="color:#859900;">..</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">2</span><span>]
</span><span>        .</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(encoded_string.</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16 </span><span>+ </span><span style="color:#6c71c4;">7</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>    </span><span style="color:#93a1a1;">// Protocol version
</span><span>    ping_vec[</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">2</span><span style="color:#859900;">..</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">4</span><span>]
</span><span>        .</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#cb4b16;">PROTOCOL_VER_1_6</span><span>.</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>    </span><span style="color:#93a1a1;">// Length of hostname
</span><span>    ping_vec[</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">2</span><span style="color:#859900;">..</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">4</span><span>]
</span><span>        .</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(encoded_string.</span><span style="color:#859900;">len</span><span>() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u16</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>    </span><span style="color:#93a1a1;">// Hostname
</span><span>    </span><span style="color:#268bd2;">let</span><span> four_before_end = ping_vec.</span><span style="color:#859900;">len</span><span>() - </span><span style="color:#6c71c4;">4</span><span>;
</span><span>    ping_vec[</span><span style="color:#cb4b16;">MINECRAFT_1_6_PING</span><span>.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">4</span><span style="color:#859900;">..</span><span>four_before_end].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>encoded_string);
</span><span>    </span><span style="color:#93a1a1;">// Port
</span><span>    ping_vec[four_before_end</span><span style="color:#859900;">..</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>(port </span><span style="color:#859900;">as </span><span style="color:#268bd2;">i32</span><span>).</span><span style="color:#859900;">to_be_bytes</span><span>()); </span><span style="color:#93a1a1;">// Mojang is quirky and decides ports are C ints now
</span><span>
</span><span>    ping_vec
</span><span>}
</span></code></pre>
<p>All this does is add the ping header, the protocol version, the hostname and the port together. Technically only the first three bytes are needed for any server to respond (nothing else is actually used) - but just in case (for example some strange custom servers on a crusade to enforce client protocol compliance), the full header is included. I don't think the one allocation will be a bottleneck, and better not to do premature optimization. However, if it indeed improves performance, sending just the three bytes could have the potential to greatly improve performance.</p>
<p>The 1.7 ping is similar:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">NETTY_STATUS_ID</span><span>: </span><span style="color:#268bd2;">u8 </span><span>= </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">NETTY_PROTOCOL_VER</span><span>: </span><span style="color:#268bd2;">u8 </span><span>= </span><span style="color:#6c71c4;">0</span><span>;
</span><span style="color:#268bd2;">const </span><span style="color:#cb4b16;">STATUS_REQUEST_STATE</span><span>: </span><span style="color:#268bd2;">u8 </span><span>= </span><span style="color:#6c71c4;">1</span><span>;
</span><span>
</span><span style="color:#93a1a1;">// https://wiki.vg/Server_List_Ping#Current_.281.7.2B.29
</span><span style="color:#93a1a1;">/// Constructs a 1.7+ netty minecraft SLP packet
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">construct_netty_ping</span><span>(</span><span style="color:#268bd2;">hostname</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">str</span><span>, </span><span style="color:#268bd2;">port</span><span>: </span><span style="color:#268bd2;">u16</span><span>) -&gt; </span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt; {
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> ping_vec: </span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#268bd2;">u8</span><span>&gt; = </span><span style="color:#859900;">Vec</span><span>::with_capacity(hostname.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">5</span><span>);
</span><span>
</span><span>    ping_vec[</span><span style="color:#6c71c4;">0</span><span>] = </span><span style="color:#cb4b16;">NETTY_STATUS_ID</span><span>;
</span><span>    ping_vec[</span><span style="color:#6c71c4;">1</span><span>] = </span><span style="color:#cb4b16;">NETTY_PROTOCOL_VER</span><span>;
</span><span>    ping_vec[</span><span style="color:#6c71c4;">2</span><span style="color:#859900;">..</span><span>hostname.</span><span style="color:#859900;">len</span><span>() + </span><span style="color:#6c71c4;">2</span><span>].</span><span style="color:#859900;">copy_from_slice</span><span>(hostname.</span><span style="color:#859900;">as_bytes</span><span>());
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> server_port_slice = ping_vec.</span><span style="color:#859900;">len</span><span>() - </span><span style="color:#6c71c4;">3</span><span style="color:#859900;">..</span><span>ping_vec.</span><span style="color:#859900;">len</span><span>() - </span><span style="color:#6c71c4;">1</span><span>;
</span><span>    ping_vec[server_port_slice].</span><span style="color:#859900;">copy_from_slice</span><span>(</span><span style="color:#859900;">&amp;</span><span>port.</span><span style="color:#859900;">to_be_bytes</span><span>());
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> last_element = ping_vec.</span><span style="color:#859900;">len</span><span>();
</span><span>    ping_vec[last_element] = </span><span style="color:#cb4b16;">STATUS_REQUEST_STATE</span><span>;
</span><span>
</span><span>    ping_vec
</span><span>}
</span></code></pre>
<p>Pretty much the same data is sent.</p>
<p>Now onto receiving, let's define the data structures we want first:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Clone)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">enum </span><span style="color:#b58900;">MinecraftSlp </span><span>{
</span><span>    Legacy(LegacyPingResponse),
</span><span>    Netty(NettyPingResponse),
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Clone)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">LegacyPingResponse </span><span>{
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">protocol_version</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">i64</span><span>&gt;,
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">server_version</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">motd</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">current_players</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">i64</span><span>&gt;,
</span><span>    </span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">max_players</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">i64</span><span>&gt;,
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Clone)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">NettyPingResponse </span><span>{
</span><span>    </span><span style="color:#268bd2;">version_name</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">protocol</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">i64</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">max_players</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">i64</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">online_players</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">i64</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">online_sample</span><span>: </span><span style="color:#859900;">Vec</span><span>&lt;Player&gt;,
</span><span>    </span><span style="color:#268bd2;">motd</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">enforces_secure_chat</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">bool</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">previews_chat</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#268bd2;">bool</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">favicon</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#268bd2;">derive</span><span>(Debug, Clone)]
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">Player </span><span>{
</span><span>    </span><span style="color:#268bd2;">name</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">id</span><span>: </span><span style="color:#859900;">Option</span><span>&lt;</span><span style="color:#859900;">String</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>The idea is for the SLPs to try to be deserialized with both the 1.6 and 1.7 deserializers in succession, so no state is required to be stored. You can read more on the wiki, but the jist of the 1.6 ping response is it's just a packed structure of info:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">/// Processes a server&#39;s 1.6 or earlier legacy ping response
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">process_server_1_6_ping</span><span>(</span><span style="color:#268bd2;">packet</span><span>: </span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#268bd2;">u8</span><span>]) -&gt; </span><span style="color:#859900;">Option</span><span>&lt;LegacyPingResponse&gt; {
</span><span>    </span><span style="color:#93a1a1;">// Check 0xFF packet ID
</span><span>    </span><span style="color:#859900;">if</span><span> packet.</span><span style="color:#859900;">first</span><span>()</span><span style="color:#859900;">? </span><span>!= </span><span style="color:#859900;">&amp;</span><span style="color:#6c71c4;">0xff </span><span>{
</span><span>        </span><span style="color:#859900;">return None</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// Check ¬ß1\x00\x00 magic string
</span><span>    </span><span style="color:#859900;">if</span><span> packet.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">3</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">9</span><span>)</span><span style="color:#859900;">? </span><span>!= [</span><span style="color:#6c71c4;">00</span><span>, </span><span style="color:#6c71c4;">167</span><span>, </span><span style="color:#6c71c4;">00</span><span>, </span><span style="color:#6c71c4;">31</span><span>, </span><span style="color:#6c71c4;">00</span><span>, </span><span style="color:#6c71c4;">00</span><span>] {
</span><span>        </span><span style="color:#859900;">return None</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> null_delim_string = NullDelimitedString::new(bytemuck::pod_align_to(packet.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">9</span><span style="color:#859900;">..</span><span>)</span><span style="color:#859900;">?</span><span>).</span><span style="color:#6c71c4;">1</span><span>);
</span><span>    </span><span style="color:#268bd2;">let</span><span> info_string = null_delim_string.</span><span style="color:#859900;">fields</span><span>();
</span><span>
</span><span>    </span><span style="color:#859900;">Some</span><span>(LegacyPingResponse {
</span><span>        protocol_version: info_string
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">0</span><span>)
</span><span>            .</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">s</span><span>| </span><span style="color:#859900;">String</span><span>::from_utf16(s))
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(</span><span style="color:#859900;">Result</span><span>::ok)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| s.</span><span style="color:#859900;">parse</span><span>().</span><span style="color:#859900;">ok</span><span>()),
</span><span>        server_version: info_string.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">1</span><span>).</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| </span><span style="color:#859900;">String</span><span>::from_utf16(s).</span><span style="color:#859900;">ok</span><span>()),
</span><span>        motd: info_string.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">1</span><span>).</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| </span><span style="color:#859900;">String</span><span>::from_utf16(s).</span><span style="color:#859900;">ok</span><span>()),
</span><span>        current_players: info_string
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">3</span><span>)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| </span><span style="color:#859900;">String</span><span>::from_utf16(s).</span><span style="color:#859900;">ok</span><span>())
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| s.</span><span style="color:#859900;">parse</span><span>().</span><span style="color:#859900;">ok</span><span>()),
</span><span>        max_players: info_string
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">4</span><span>)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| </span><span style="color:#859900;">String</span><span>::from_utf16(s).</span><span style="color:#859900;">ok</span><span>())
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">s</span><span>| s.</span><span style="color:#859900;">parse</span><span>().</span><span style="color:#859900;">ok</span><span>()),
</span><span>    })
</span><span>}
</span><span>
</span><span style="color:#93a1a1;">// 16 bit word string composed of fields separated by \x00\x00 that the legacy ping uses
</span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">NullDelimitedString</span><span>&lt;</span><span style="color:#586e75;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#268bd2;">data</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">&#39;a</span><span> [</span><span style="color:#268bd2;">u16</span><span>],
</span><span>    </span><span style="color:#268bd2;">counter</span><span>: </span><span style="color:#268bd2;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#268bd2;">impl</span><span>&lt;</span><span style="color:#586e75;">&#39;a</span><span>&gt; </span><span style="color:#b58900;">NullDelimitedString</span><span>&lt;</span><span style="color:#586e75;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">new</span><span>(</span><span style="color:#268bd2;">data</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">&#39;a</span><span> [</span><span style="color:#268bd2;">u16</span><span>]) -&gt; </span><span style="color:#268bd2;">Self </span><span>{
</span><span>        NullDelimitedString { data, counter: </span><span style="color:#6c71c4;">0 </span><span>}
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// Convert into \x00\x00 separated fields
</span><span>    </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">fields</span><span>(</span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">self</span><span>) -&gt; </span><span style="color:#859900;">Vec</span><span>&lt;</span><span style="color:#859900;">&amp;</span><span>[</span><span style="color:#268bd2;">u16</span><span>]&gt; {
</span><span>        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span> fields = </span><span style="color:#859900;">Vec</span><span>::with_capacity(</span><span style="color:#6c71c4;">5</span><span>); </span><span style="color:#93a1a1;">// 5 fields in a correctly formed legacy ping response
</span><span>
</span><span>        </span><span style="color:#d33682;">self</span><span>.data
</span><span>            .</span><span style="color:#859900;">split</span><span>(|</span><span style="color:#859900;">&amp;</span><span style="color:#268bd2;">c</span><span>| c == </span><span style="color:#6c71c4;">0x00</span><span>)
</span><span>            .</span><span style="color:#859900;">for_each</span><span>(|</span><span style="color:#268bd2;">field</span><span>| fields.</span><span style="color:#859900;">push</span><span>(field));
</span><span>
</span><span>        fields
</span><span>    }
</span><span>}
</span></code></pre>
<p>And the 1.7 structure is just json:</p>
<pre data-lang="rust" style="background-color:#fdf6e3;color:#657b83;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">/// Processes a 1.7+ netty SLP response
</span><span style="color:#93a1a1;">/// Needs mutability for simd_json performance
</span><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">process_server_netty_ping</span><span>(</span><span style="color:#268bd2;">packet</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span> [</span><span style="color:#268bd2;">u8</span><span>]) -&gt; </span><span style="color:#859900;">Option</span><span>&lt;NettyPingResponse&gt; {
</span><span>    </span><span style="color:#93a1a1;">// Check packet ID
</span><span>    </span><span style="color:#859900;">if</span><span> packet.</span><span style="color:#859900;">first</span><span>()</span><span style="color:#859900;">? </span><span>!= </span><span style="color:#859900;">&amp;</span><span style="color:#cb4b16;">NETTY_STATUS_ID </span><span>{
</span><span>        </span><span style="color:#859900;">return None</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#93a1a1;">// The next 1-2 bytes are a length field as a varint (so if the first bit of the first byte is set then it&#39;s two bytes)
</span><span>    </span><span style="color:#268bd2;">let</span><span> string_start_index = </span><span style="color:#859900;">if</span><span> packet.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#6c71c4;">1</span><span>)</span><span style="color:#859900;">? &amp; </span><span style="color:#6c71c4;">0b10000000 </span><span>== </span><span style="color:#6c71c4;">0 </span><span>{
</span><span>        </span><span style="color:#6c71c4;">2
</span><span>    } </span><span style="color:#859900;">else </span><span>{
</span><span>        </span><span style="color:#6c71c4;">3
</span><span>    };
</span><span>    </span><span style="color:#268bd2;">let</span><span> json_response = simd_json::to_borrowed_value(packet.</span><span style="color:#859900;">get_mut</span><span>(string_start_index</span><span style="color:#859900;">..</span><span>)</span><span style="color:#859900;">?</span><span>).</span><span style="color:#859900;">ok</span><span>()</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> json_response = json_response.</span><span style="color:#859900;">as_object</span><span>()</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> version_object = json_response.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">version</span><span style="color:#839496;">&quot;</span><span>);
</span><span>    </span><span style="color:#268bd2;">let</span><span> version_object = version_object.</span><span style="color:#859900;">as_object</span><span>();
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> players_object = json_response.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">players</span><span style="color:#839496;">&quot;</span><span>);
</span><span>    </span><span style="color:#268bd2;">let</span><span> players_object = players_object.</span><span style="color:#859900;">as_object</span><span>();
</span><span>
</span><span>    </span><span style="color:#859900;">Some</span><span>(NettyPingResponse {
</span><span>        version_name: version_object
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">version</span><span>| version.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">name</span><span style="color:#839496;">&quot;</span><span>))
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_str)
</span><span>            .</span><span style="color:#859900;">map</span><span>(</span><span style="color:#268bd2;">str</span><span>::to_owned),
</span><span>        protocol: version_object.</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">version</span><span>| version.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">protocol</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_i64</span><span>()),
</span><span>        max_players: players_object.</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">players</span><span>| players.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">max</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_i64</span><span>()),
</span><span>        online_players: players_object.</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">players</span><span>| players.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">online</span><span style="color:#839496;">&quot;</span><span>)</span><span style="color:#859900;">?</span><span>.</span><span style="color:#859900;">as_i64</span><span>()),
</span><span>        online_sample: players_object
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(|</span><span style="color:#268bd2;">players</span><span>| players.</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">sample</span><span style="color:#839496;">&quot;</span><span>))
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_array)
</span><span>            .</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">players_array</span><span>| {
</span><span>                players_array
</span><span>                    .</span><span style="color:#859900;">iter</span><span>()
</span><span>                    .</span><span style="color:#859900;">map</span><span>(|</span><span style="color:#268bd2;">player</span><span>| Player {
</span><span>                        name: player
</span><span>                            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">name</span><span style="color:#839496;">&quot;</span><span>)
</span><span>                            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_str)
</span><span>                            .</span><span style="color:#859900;">map</span><span>(</span><span style="color:#268bd2;">str</span><span>::to_owned),
</span><span>                        id: player
</span><span>                            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">id</span><span style="color:#839496;">&quot;</span><span>)
</span><span>                            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_str)
</span><span>                            .</span><span style="color:#859900;">map</span><span>(</span><span style="color:#268bd2;">str</span><span>::to_owned),
</span><span>                    })
</span><span>                    .</span><span style="color:#859900;">collect</span><span>()
</span><span>            })
</span><span>            .</span><span style="color:#859900;">unwrap_or_default</span><span>(),
</span><span>        motd: json_response
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">description</span><span style="color:#839496;">&quot;</span><span>)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_str)
</span><span>            .</span><span style="color:#859900;">map</span><span>(</span><span style="color:#268bd2;">str</span><span>::to_owned),
</span><span>        enforces_secure_chat: json_response
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">enforcesSecureChat</span><span style="color:#839496;">&quot;</span><span>)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_bool),
</span><span>        previews_chat: json_response
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">previewsChat</span><span style="color:#839496;">&quot;</span><span>)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_bool),
</span><span>        favicon: json_response
</span><span>            .</span><span style="color:#859900;">get</span><span>(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">favicon</span><span style="color:#839496;">&quot;</span><span>)
</span><span>            .</span><span style="color:#859900;">and_then</span><span>(ValueAccess::as_str)
</span><span>            .</span><span style="color:#859900;">map</span><span>(</span><span style="color:#268bd2;">str</span><span>::to_owned),
</span><span>    })
</span><span>}
</span></code></pre>
<p>The transmitting and receiving is easy from there - the most interesting part is getting around the lack of concurrent transmitting in the socket api using parking synchronization (so just a glorified dataless mutex). This is not an issue with receiving because (at least with ethernet) receivers are physically separate cables so concurrent use is allowed.</p>
<p><em>Not continued! - I don't see a point to finishing unless someone wants to buy me a VPS to join the hundreds of servers scanning Minecraft servers already, but you're welcome to try completing it - all the &quot;hard parts&quot; are done.</em></p>
<p><hr data-content="future ideas" \>
Assorted thoughts on extending this scanner</p>
<ul>
<li>login attempt scans instead of ping scans, in case people start blocking pings</li>
<li>perhaps scanning CDN IPs is feasible, because one could look through certificate transparency logs to get a list of domains, and try each of them in the hostname field of a Minecraft packet. However, rate limiting could be an issue.</li>
<li>there are some bugs - a malicious server can spam us response data, and some servers may segment TCP responses. Both can be fixed by storing connection states like masscan.</li>
<li>this scanner uses parkers to synchronize receive and transmit thread sends - masscan uses channels so all sending happens on the main thread. Still haven't benchmarked which one is faster with crossbeam in Rust.</li>
</ul>


            </main>
            <footer>
                
<script src="https://giscus.app/client.js"
        data-repo="Dev380/Dev380.github.io"
        data-repo-id="R_kgDOJ11zZw"
        data-category="Comments"
        data-category-id="DIC_kwDOJ11zZ84CXkg-"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
<p class="taxonomies">

</p>

                
            </footer>
        </div>
    </body>
</html>
        
